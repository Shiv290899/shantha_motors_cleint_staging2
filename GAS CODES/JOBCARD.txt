function doGet(e){ return handle_(e) }
function doPost(e){ return handle_(e) }

// If bound to the sheet, keep blank. Otherwise set your spreadsheet ID.
const SHEET_ID = '';
const SHEET_NAME = 'Sheet1';

// Default headers (used only when the sheet is empty).
// Existing sheets are read dynamically and not overwritten.
const DEFAULT_HEADERS = [
  'Timestamp',
  'Customer_Name',
  'Mobile',
  'Collected_Amount',
  'Vehicle_No',
  'Company',
  'Service_Type',
  'Chassis No',
  'Branch',
  'Customer_Observation',
  'Expected_Delivery_Date',
  'Payload',
  'Updated At',
  'Payment_Mode',
  'JC No.',
  'RemarkLevel',
  'RemarkText'
];

// Append-only service history (separate sheet; jcNo is idempotency key)
const SERVICE_HISTORY_SHEET = 'ServiceHistory';
const SERVICE_HISTORY_HEADERS = [
  'Created At',
  'Post Service At',
  'JC No',
  'Reg No',
  'Mobile',
  'Customer Name',
  'Branch',
  'Service Type',
  'Chassis No',
  'Vehicle Type',
  'Company',
  'Model',
  'Colour',
  'Mechanic',
  'Executive',
  'Service No',
  'KM',
  'Fuel Level',
  'Payment Mode',
  'Collected Amount',
  'Totals Grand',
  'Work Done',
  'Remarks',
  'Payments JSON',
  'Payload JSON'
];

/* ============== DAILY COLLECTIONS (MASTER) CONFIG ============== */
const DC_MASTER_SPREADSHEET_ID = '1oYOaFhEr7PgdF0BDC5A4V2zfPPoFtnhbxcP16jMqiGs';
const DC_SHEET = 'DailyCollections';

const DC_HEADERS = [
  'Date','Branch','Staff',
  'Booking Amount','JC Amount','Minor Sales Amount',
  'Total', // legacy total field (keep for compatibility)
  'Cash Amount','Online Amount','Total Collected', // total collected = cash + online
  'Opening Balance','Due Today','Collected Today','Closing Balance',
  'Settlement Done','Settlement At','Updated At','Notes','Raw Payload'
];

function handle_(e){
  try{
    const body = (e && e.postData && e.postData.contents) ? JSON.parse(e.postData.contents) : {};
    const action = String(
      (e && e.parameter && e.parameter.action) ||
      body.action ||
      (body.data && body.data.action) ||
      ''
    ).toLowerCase();

    if (action === 'nextserial') return json_({ success:true, nextSerial: nextSerial_() });

    if (action === 'list') {
      const p = e && e.parameter ? e.parameter : {};
      const branch = String((p.branch != null ? p.branch : (body.branch || '')));
      const executive = String((p.executive != null ? p.executive : (body.executive || '')));
      const service = String((p.service != null ? p.service : (body.service || ''))).toLowerCase();
      const status = String((p.status != null ? p.status : (body.status || ''))).toLowerCase();
      const sinceISO = String((p.since != null ? p.since : (body.since || '')));
      const untilISO = String((p.until != null ? p.until : (body.until || '')));
      const startMs = p.start ? +p.start : (body.start ? +body.start : null);
      const endMs = p.end ? +p.end : (body.end ? +body.end : null);
      const q = String((p.q != null ? p.q : (body.q || '')));
      const page = Math.max(parseInt((p.page != null ? p.page : (body.page || '1')), 10) || 1, 1);
      const pageSize = Math.min(100, Math.max(0, parseInt((p.pageSize != null ? p.pageSize : (body.pageSize || body.pagesize || '0')), 10) || 0));
      const limit = Math.max(parseInt((p.limit != null ? p.limit : (body.limit || '0')), 10) || 0, 0);

      const resp = list_({
        branch, executive, service, status, sinceISO, untilISO, startMs, endMs,
        q,
        page, pageSize, limit
      });
      return json_(resp);
    }

    if (action === 'search') {
      const mode = ((e && e.parameter && e.parameter.mode) || body.mode || 'jc').toLowerCase();
      const query = String(((e && e.parameter && e.parameter.query) || body.query || ''));
      return json_( { success:true, rows: search_(mode, query) } );
    }

    if (action === 'getservicehistory') {
      const params = Object.assign({}, e && e.parameter ? e.parameter : {}, body);
      return json_(getServiceHistory_(params));
    }

    if (action === 'save') {
      const data = body.data || body;
      return json_(save_(data)); // upsert by mobile
    }

    if (action === 'postservice') {
      const data = body.data || body;
      return json_(postService_(data)); // upsert by mobile + DailyCollections
    }

    if (action === 'followups') {
      const filter = (((e && e.parameter && e.parameter.filter) || body.filter || 'today')+'').toLowerCase(); // today|overdue|upcoming|all
      const branch = String(((e && e.parameter && e.parameter.branch) || body.branch || ''));
      const executive = String(((e && e.parameter && e.parameter.executive) || body.executive || ''));
      return json_(followups_(filter, branch, executive));
    }

    if (action === 'updatefollowup') {
      const serialNo = String(((e && e.parameter && e.parameter.serialNo) || body.serialNo || ''));
      const patch = body.patch || {};
      return json_(updateFollowup_(serialNo, patch));
    }

    if (action === 'remark') {
      const jcNo = String(((e && e.parameter && e.parameter.jcNo) || body.jcNo || '')).trim();
      const level = String(((e && e.parameter && e.parameter.level) || body.level || '')).toLowerCase(); // ok|warning|alert
      const text = String(((e && e.parameter && e.parameter.text) || body.text || '')).trim();
      const by = String(((e && e.parameter && e.parameter.by) || body.by || '')).trim(); // optional
      return json_(updateRemark_(jcNo, level, text, by));
    }

    // Admin views for Daily Collections (uses master file)
    if (action === 'collections') {
      const p = e && e.parameter ? e.parameter : {};
      return json_(collections_({
        branch:   p.branch   || body.branch   || '',
        date:     p.date     || body.date     || '',
        page:     p.page     || body.page     || '1',
        pageSize: p.pageSize || body.pageSize || '10'
      }));
    }

    if (action === 'settle_collection') {
      const p = e && e.parameter ? e.parameter : {};
      const b = p.branch || body.branch || '';
      const s = p.staff  || body.staff  || '';
      const d = p.date   || body.date   || '';
      return json_(settleCollection_(b, s, d));
    }

    if (action === 'update_collection') {
      const p = e && e.parameter ? e.parameter : {};
      const b = p.branch || body.branch || '';
      const s = p.staff  || body.staff  || '';
      const d = p.date   || body.date   || '';
      const collectedToday = (p.collectedToday != null ? p.collectedToday : body.collectedToday);
      return json_(updateCollectionDC_({ date:d, branch:b, staff:s, collectedToday }));
    }

    if (action === 'staff_collection_summary') {
      const p = e && e.parameter ? e.parameter : {};
      const b = p.branch || body.branch || '';
      const s = p.staff  || body.staff  || '';
      return json_(getStaffCollectionSummary_(b, s));
    }

    if (action === 'dc_test') {
      return json_(updateDailyCollection_('Muddinapalya','Rukmini',123,'jc'));
    }

    // ===== Staff Ledger (NEW endpoints) =====
    if (action === 'staff_ledger_summary') {
      const p = e && e.parameter ? e.parameter : {};
      const b = p.branch || body.branch || '';
      const s = p.staff  || body.staff  || '';
      return json_(staffLedgerSummary_(b, s));
    }

    if (action === 'staff_ledger_transactions') {
      const p = e && e.parameter ? e.parameter : {};
      const b = p.branch || body.branch || '';
      const s = p.staff  || body.staff  || '';
      const mode = (p.mode || body.mode || 'all')+'';
      return json_(staffLedgerTransactions_(b, s, mode));
    }

    if (action === 'owner_ledger_list') {
      const p = e && e.parameter ? e.parameter : {};
      const branch = p.branch || body.branch || '';
      const staff = p.staff || body.staff || '';
      const status = (p.status || body.status || 'unsettled')+'';
      const fromDate = p.fromDate || body.fromDate || '';
      const toDate = p.toDate || body.toDate || '';
      return json_(ownerLedgerList_({ branch, staff, status, fromDate, toDate }));
    }

    if (action === 'owner_ledger_settle') {
      const p = e && e.parameter ? e.parameter : {};
      const branch = p.branch || body.branch || '';
      const staff = p.staff || body.staff || '';
      const mode = (p.mode || body.mode || 'both')+'';
      const idsRaw = (p.ids || body.ids || '');
      const settledBy = p.settledBy || body.settledBy || 'OWNER';
      const ids = Array.isArray(idsRaw)
        ? idsRaw.map(x=>+x).filter(n=>Number.isFinite(n))
        : String(idsRaw||'').split(/[,\s]+/).map(x=>+x).filter(n=>Number.isFinite(n));
      const rv = staffLedgerSettleRows_(ids, mode, settledBy, { branch, staff });
      return json_({ success:true, updatedCount: rv.updatedCount||0 });
    }

    if (action === 'owner_prev_due_list') {
      const p = e && e.parameter ? e.parameter : {};
      const branch = p.branch || body.branch || '';
      const staff = p.staff || body.staff || '';
      return json_(ownerPrevDueList_({ branch, staff }));
    }

    if (action === 'owner_prev_due_set') {
      const p = e && e.parameter ? e.parameter : {};
      const branch = p.branch || body.branch || '';
      const staff = p.staff || body.staff || '';
      const amount = (p.amount != null ? p.amount : (body.amount != null ? body.amount : undefined));
      const note = p.note != null ? p.note : body.note;
      const updatedBy = p.updatedBy || body.updatedBy || 'OWNER';
      return json_(ownerPrevDueSet_(branch, staff, amount, note, updatedBy));
    }

    return json_({
      ok:true,
      hint:'actions: list, nextSerial, search, save, postService, followups, updateFollowup, remark, collections, update_collection, settle_collection, staff_collection_summary, dc_test'
    });
  }catch(err){
    return json_({ success:false, error:String(err) });
  }
}

function json_(o){
  return ContentService.createTextOutput(JSON.stringify(o))
    .setMimeType(ContentService.MimeType.JSON);
}

function sh_(){
  const ss = SHEET_ID ? SpreadsheetApp.openById(SHEET_ID) : SpreadsheetApp.getActiveSpreadsheet();
  const s = ss.getSheetByName(SHEET_NAME) || ss.getSheets()[0];

  // Seed headers only if the first row is empty
  const width = Math.max(s.getLastColumn(), DEFAULT_HEADERS.length);
  const first = s.getRange(1,1,1,width).getValues()[0];
  const hasAny = first.some(v => String(v||'').trim().length);
  if (!hasAny) s.getRange(1,1,1,DEFAULT_HEADERS.length).setValues([DEFAULT_HEADERS]);

  return s;
}

function norm_(s){ return String(s || '').trim().toLowerCase(); }
function normReg_(s){ return String(s || '').toUpperCase().replace(/\s+/g,''); }

function headerIx_(s){
  const width = Math.max(s.getLastColumn(), DEFAULT_HEADERS.length);
  const H = s.getRange(1,1,1,width).getValues()[0].map(x => String(x||'').trim());

  const pos = (rx) => H.findIndex(h => rx.test(h));
  const posAll = (rx) => H.map((h,i)=>rx.test(h)?i:-1).filter(i=>i>=0);

  return {
    headers: H, width,
    idxTime: pos(/^(timestamp|created\s*at|submitted|submission)/i),
    idxName: pos(/(customer[\s_]*name|^name$)/i),
    idxMobile: pos(/(mobile|phone)/i),
    idxAmount: pos(/collected[\s_]*amount/i),
    idxReg: pos(/(vehicle[\s_]*no|registration|^reg(?:[\s_]*no)?$)/i),
    idxSvc: pos(/service[\s_]*type/i),
    idxBranch: pos(/^branch$/i),
    idxObs: pos(/(customer[\s_]*ob(?:s|servation)|observation)/i),
    idxExp: pos(/expected[\s_]*delivery/i),
    idxPayloads: posAll(/^payload$/i),
    idxPayment: pos(/^payment/i),
    idxJC: pos(/^(jc\b|job[\s_]*card)/i),
    // optional extra columns
    idxRemarkLevel: pos(/remark.*level/i),
    idxRemarkText: pos(/remark.*text/i),
    idxExecutive2: pos(/^executive$/i),
    idxMechanic: pos(/(allotted[\s_]mechanic|mechanic)$/i),
    idxCompany: pos(/^company$/i),
    idxChassis: pos(/^(chassis|chassis[\s_]*no|chassis[\s_]*number)$/i),
    idxModel: pos(/^model$/i),
    idxColour: pos(/^(colour|color)$/i),
    idxKM: pos(/^(odometer(\s*reading)?|odometer[\s_]*reading|odomete[\s_]*reading|km)$/i),
    idxFuel: pos(/^fuel[\s_]*level$/i),
    idxVehType: pos(/vehicle[\s_]*type/i),
    idxPostAt: pos(/^(post[\s_]*service[\s_]*at|post[\s_]serviced[\s_]at)$/i),
    idxUTR: pos(/^(utr(\sno|\snumber)?)/i),
    idxUpdatedAt: pos(/updated\s*at/i),
  };
}

function ensureRemarkCols_(s, info){
  let ix = info || headerIx_(s);
  if (ix.idxRemarkLevel < 0) {
    s.getRange(1, ix.headers.length + 1).setValue('RemarkLevel');
    ix = headerIx_(s);
  }
  if (ix.idxRemarkText < 0) {
    s.getRange(1, ix.headers.length + 1).setValue('RemarkText');
    ix = headerIx_(s);
  }
  return ix;
}

function ensureCol_(s, name){
  const info = headerIx_(s);
  if (info.headers.indexOf(name) >= 0) return info;
  s.getRange(1, info.headers.length + 1).setValue(name);
  return headerIx_(s);
}

function ensureColAfter_(s, name, afterName){
  const info = headerIx_(s);
  if (info.headers.indexOf(name) >= 0) return info;
  const idxAfter = info.headers.indexOf(afterName);
  if (idxAfter >= 0) {
    s.insertColumnAfter(idxAfter + 1);
    s.getRange(1, idxAfter + 2).setValue(name);
    return headerIx_(s);
  }
  s.getRange(1, info.headers.length + 1).setValue(name);
  return headerIx_(s);
}

function ensureCoreOptionalCols_(s){
  let ix = headerIx_(s);
  ['Executive','Allotted Mechanic','Company','Model','Colour','Odometer Reading','Fuel Level','Vehicle Type','Post Service At','UTR No','Updated At']
    .forEach((col) => { ix = ensureCol_(s, col); });
  ix = ensureColAfter_(s, 'Chassis No', 'Service_Type');
  return ix;
}

function nextSerial_(){
  const s = sh_(), ix = headerIx_(s);
  if (ix.idxJC < 0) return '1';
  const last = s.getLastRow();
  if (last <= 1) return '1';
  const vals = s.getRange(2, ix.idxJC+1, last-1, 1)
    .getValues()
    .map(r => parseInt(String(r[0]).trim(),10))
    .filter(n => Number.isFinite(n));
  return String((vals.length ? Math.max.apply(null, vals) : 0) + 1);
}

function ten_(x){ return String(x||'').replace(/\D/g,'').slice(-10); }
function safeJson_(x){ try{return JSON.parse(String(x||'{}'))}catch(_){return null} }
function nonEmpty_(v){ return !(v === undefined || v === null || String(v).trim() === ''); }
function pickOne_(arr){
  for (var i = 0; i < arr.length; i++) {
    if (nonEmpty_(arr[i])) return arr[i];
  }
  return '';
}
function digitsOnly_(v){ return String(v || '').replace(/\D/g, ''); }
function canonicalFormValues_(d){
  const fv = (d && d.formValues && typeof d.formValues === 'object') ? d.formValues : {};
  const pfv = (d && d.payload && d.payload.formValues && typeof d.payload.formValues === 'object') ? d.payload.formValues : {};
  const out = {};

  out.jcNo = String(pickOne_([fv.jcNo, pfv.jcNo, d && d.jcNo]) || '').trim();
  out.custName = String(pickOne_([fv.custName, fv.customerName, fv.name, pfv.custName, pfv.customerName, pfv.name]) || '').trim();
  out.custMobile = ten_(pickOne_([fv.custMobile, fv.mobile, fv.customerMobile, pfv.custMobile, pfv.mobile, pfv.customerMobile, d && d.mobile]));
  out.amount = pickOne_([fv.amount, pfv.amount, d && d.collectedAmount, d && d.serviceAmount]);
  out.paymentMode = String(pickOne_([fv.paymentMode, pfv.paymentMode, d && d.paymentMode]) || '').trim().toLowerCase();
  out.regNo = String(pickOne_([fv.regNo, fv.vehicleNo, fv.vehicle_no, pfv.regNo, pfv.vehicleNo, pfv.vehicle_no]) || '').trim();
  out.serviceType = String(pickOne_([fv.serviceType, fv.service, pfv.serviceType, pfv.service]) || '').trim();
  out.branch = String(pickOne_([fv.branch, pfv.branch, d && d.branch]) || '').trim();
  out.obs = String(pickOne_([fv.obs, fv.observation, fv.customerObservation, pfv.obs, pfv.observation, pfv.customerObservation]) || '').trim();
  out.expectedDelivery = String(pickOne_([fv.expectedDelivery, fv.expected_delivery, pfv.expectedDelivery, pfv.expected_delivery]) || '').trim();
  out.executive = String(pickOne_([fv.executive, fv.execute, fv.execName, pfv.executive, pfv.execute, pfv.execName]) || '').trim();
  out.mechanic = String(pickOne_([fv.mechanic, fv.allottedMechanic, pfv.mechanic, pfv.allottedMechanic]) || '').trim();
  out.company = String(pickOne_([fv.company, pfv.company]) || '').trim();
  out.model = String(pickOne_([fv.model, pfv.model]) || '').trim();
  out.colour = String(pickOne_([fv.colour, fv.color, pfv.colour, pfv.color]) || '').trim();
  out.chassisNo = String(pickOne_([fv.chassisNo, fv.chassis, pfv.chassisNo, pfv.chassis]) || '').trim();
  out.km = digitsOnly_(pickOne_([fv.km, fv.odometer, fv.odometerReading, fv.odometer_reading, pfv.km, pfv.odometer, pfv.odometerReading, pfv.odometer_reading]));
  out.fuelLevel = String(pickOne_([fv.fuelLevel, pfv.fuelLevel]) || '').trim();
  out.vehicleType = String(pickOne_([fv.vehicleType, pfv.vehicleType]) || '').trim();
  out.floorMat = String(pickOne_([fv.floorMat, pfv.floorMat]) || '').trim();
  out.remarks = String(pickOne_([fv.remarks, fv.remark, pfv.remarks, pfv.remark, d && d.remarks, d && d.remark]) || '').trim();
  return out;
}

function cleanPayload_(rawPayload, fv){
  if (!rawPayload || typeof rawPayload !== 'object') return {};
  const std = new Set([
    'custName','custMobile','amount','paymentMode',
    'regNo','serviceType','branch','obs','expectedDelivery','jcNo',
    'executive','mechanic','company','model','colour','color',
    'km','fuelLevel','vehicleType','chassisNo','chassis',
    'remarks','remark'
  ]);
  const out = JSON.parse(JSON.stringify(rawPayload));
  if (out.formValues && typeof out.formValues === 'object') {
    Object.keys(out.formValues).forEach(k => { if (std.has(k)) delete out.formValues[k]; });
    if (!Object.keys(out.formValues).length) delete out.formValues;
  }
  Object.keys(out).forEach(k => { if (std.has(k)) delete out[k]; });
  if (out.followUp && typeof out.followUp === 'object') {
    delete out.followUp.branch;
    delete out.followUp.assignedTo;
    delete out.followUp.customer;
  }
  return out;
}

/* ===== Robust amount + mode helpers ===== */
function computeAmount_(d){
  try{
    if (Array.isArray(d.payments) && d.payments.length) {
      const total = d.payments.reduce((acc, p) => acc + (Number(p.amount)||0), 0);
      if (total > 0) return total;
    }
    const tgRoot = Number(d?.totals?.grand || 0);
    if (tgRoot > 0) return tgRoot;
    const tgPayload = Number(d?.payload?.totals?.grand || 0);
    if (tgPayload > 0) return tgPayload;
    const ca = Number(d?.collectedAmount || 0);
    if (ca > 0) return ca;
    const fvAmt = Number(d?.formValues?.amount || 0);
    if (fvAmt > 0) return fvAmt;
    return 0;
  }catch(_){ return 0; }
}

function computeMode_(d){
  try{
    if (Array.isArray(d.payments) && d.payments.length) {
      const modes = d.payments
        .map(p => String(p.mode||'').trim().toLowerCase())
        .filter(Boolean);
      const uniq = Array.from(new Set(modes));
      if (uniq.length === 1) return uniq[0];
      if (uniq.length > 1) return 'mixed';
    }
    if (d.paymentMode) return String(d.paymentMode).toLowerCase();
    if (d.formValues && d.formValues.paymentMode) return String(d.formValues.paymentMode).toLowerCase();
    return '';
  }catch(_){ return ''; }
}

/* ============ Service History (append-only; keyed by jcNo) ============ */
function serviceHistorySheet_(){
  const ss = SHEET_ID ? SpreadsheetApp.openById(SHEET_ID) : SpreadsheetApp.getActiveSpreadsheet();
  let sh = ss.getSheetByName(SERVICE_HISTORY_SHEET);
  if (!sh) {
    sh = ss.insertSheet(SERVICE_HISTORY_SHEET);
    sh.appendRow(SERVICE_HISTORY_HEADERS);
  }
  const width = Math.max(sh.getLastColumn(), SERVICE_HISTORY_HEADERS.length);
  const first = sh.getRange(1,1,1,width).getValues()[0];
  const hasAny = first.some(v => String(v||'').trim());
  if (!hasAny) {
    sh.getRange(1,1,1,SERVICE_HISTORY_HEADERS.length).setValues([SERVICE_HISTORY_HEADERS]);
  }
  return sh;
}

function serviceHistoryIx_(headers){
  const norm = (s) => String(s||'').trim().toLowerCase();
  const H = headers.map(norm);
  const find = (name) => H.indexOf(norm(name));
  return {
    CreatedAt: find('created at'),
    PostAt: find('post service at'),
    JCNo: find('jc no'),
    RegNo: find('reg no'),
    Mobile: find('mobile'),
    CustName: find('customer name'),
    Branch: find('branch'),
    ServiceType: find('service type'),
    VehicleType: find('vehicle type'),
    Company: find('company'),
    ChassisNo: find('chassis no'),
    Model: find('model'),
    Colour: find('colour'),
    Mechanic: find('mechanic'),
    Executive: find('executive'),
    ServiceNo: find('service no'),
    KM: find('km'),
    Fuel: find('fuel level'),
    PaymentMode: find('payment mode'),
    CollectedAmount: find('collected amount'),
    TotalsGrand: find('totals grand'),
    WorkDone: find('work done'),
    Remarks: find('remarks'),
    CustObs: find('customer observation'),
    PaymentsJson: find('payments json'),
    PayloadJson: find('payload json'),
    width: headers.length
  };
}

function ensureServiceHistoryCol_(sh, name){
  const width = Math.max(sh.getLastColumn(), SERVICE_HISTORY_HEADERS.length);
  const headers = sh.getRange(1,1,1,width).getValues()[0];
  if (headers.indexOf(name) >= 0) return;
  sh.getRange(1, headers.length + 1).setValue(name);
}

function upsertServiceHistory_(d){
  try{
    const jcNo = String(d?.jcNo || d?.formValues?.jcNo || d?.payload?.formValues?.jcNo || '').trim();
    if (!jcNo) return { success:false, message:'jcNo missing' };
    const sh = serviceHistorySheet_();
    ensureServiceHistoryCol_(sh, 'Customer Observation');
    ensureServiceHistoryCol_(sh, 'Company');
    const width = Math.max(sh.getLastColumn(), SERVICE_HISTORY_HEADERS.length);
    const headers = sh.getRange(1,1,1,width).getValues()[0];
    const I = serviceHistoryIx_(headers);
    const last = sh.getLastRow();
    const rows = (last > 1) ? sh.getRange(2,1,last-1,I.width).getValues() : [];

    const regNo = normReg_(d?.regNo || d?.formValues?.regNo || d?.payload?.formValues?.regNo || d?.payload?.regNo || '');
    const chassisNo = String(d?.chassisNo || d?.formValues?.chassisNo || d?.payload?.formValues?.chassisNo || d?.payload?.chassisNo || '').toUpperCase();
    const mobile = ten_(d?.mobile || d?.formValues?.custMobile || d?.payload?.formValues?.custMobile || d?.payload?.mobile || '');
    const custName = d?.custName || d?.formValues?.custName || d?.payload?.formValues?.custName || '';
    const branch = d?.branch || d?.formValues?.branch || d?.payload?.formValues?.branch || '';
    const serviceType = d?.serviceType || d?.formValues?.serviceType || d?.payload?.formValues?.serviceType || '';
    const vehicleType = d?.vehicleType || d?.formValues?.vehicleType || d?.payload?.formValues?.vehicleType || '';
    const company = d?.company || d?.formValues?.company || d?.payload?.formValues?.company || '';
    const model = d?.model || d?.formValues?.model || d?.payload?.formValues?.model || '';
    const colour = d?.colour || d?.color || d?.formValues?.colour || d?.formValues?.color || d?.payload?.formValues?.colour || d?.payload?.formValues?.color || '';
    const mechanic = d?.mechanic || d?.formValues?.mechanic || d?.payload?.formValues?.mechanic || '';
    const executive = d?.executive || d?.formValues?.executive || d?.payload?.formValues?.executive || '';
    const km = d?.km || d?.formValues?.km || d?.payload?.formValues?.km || '';
    const fuelLevel = d?.fuelLevel || d?.formValues?.fuelLevel || d?.payload?.formValues?.fuelLevel || '';
    const paymentMode = computeMode_(d) || d?.paymentMode || d?.formValues?.paymentMode || d?.payload?.formValues?.paymentMode || '';
    const amount = computeAmount_(d) || d?.collectedAmount || d?.formValues?.amount || d?.payload?.collectedAmount || d?.payload?.totals?.grand || '';
    const totalsGrand = d?.totals?.grand || d?.payload?.totals?.grand || amount || '';
    const postServiceAt = d?.postServiceAt || d?.payload?.postServiceAt || '';
    const createdAt = d?.createdAt || d?.timestamp || d?.ts || d?.payload?.createdAt || postServiceAt || new Date().toISOString();
  const remarkText =
    d?.remark ||
    d?.remarks ||
    d?.formValues?.remarks ||
    d?.payload?.remarks ||
    (d?.payload?.remark && d.payload.remark.text) ||
    d?.payload?.formValues?.remarks ||
    '';
    const custObs =
      d?.obs ||
      d?.formValues?.obs ||
      d?.payload?.obs ||
      d?.payload?.formValues?.obs ||
      '';
    
    const paymentsJson = JSON.stringify(d?.payments || d?.payload?.payments || []);
    const payloadJson = JSON.stringify(d || {});
    const workDone = Array.isArray(d?.labourRows || d?.payload?.labourRows)
      ? (d.labourRows || d.payload.labourRows)
          .map(r => r?.item || r?.Item || r?.Description || r?.desc || '')
          .filter(Boolean)
          .join(', ')
      : '';

    let existing = null;
    for (let i = rows.length - 1; i >= 0; i--) {
      const jc = String(rows[i][I.JCNo] || '').trim();
      if (jc && jc.toUpperCase() === jcNo.toUpperCase()) {
        existing = { row: i + 2, values: rows[i] };
        break;
      }
    }
    const regCount = regNo ? rows.filter(r => normReg_(r[I.RegNo]) === regNo).length : 0;
    const serviceNo = existing
      ? (Number(rows[existing.row - 2][I.ServiceNo]) || regCount || 1)
      : (regCount + 1);

    const row = new Array(I.width).fill('');
    const put = (idx, val) => { if (idx >= 0) row[idx] = (val === undefined || val === null) ? '' : val; };
    put(I.CreatedAt, createdAt);
    put(I.PostAt, postServiceAt || createdAt);
    put(I.JCNo, jcNo);
    put(I.RegNo, regNo);
    put(I.Mobile, mobile);
    put(I.CustName, custName);
    put(I.Branch, branch);
    put(I.ServiceType, serviceType);
    put(I.VehicleType, vehicleType);
    put(I.Company, company);
    put(I.ChassisNo, chassisNo);
    put(I.Model, model);
    put(I.Colour, colour);
    put(I.Mechanic, mechanic);
    put(I.Executive, executive);
    put(I.ServiceNo, serviceNo);
    put(I.KM, km);
    put(I.Fuel, fuelLevel);
    put(I.PaymentMode, paymentMode);
    put(I.CollectedAmount, amount);
    put(I.TotalsGrand, totalsGrand);
    put(I.WorkDone, workDone);
    put(I.Remarks, remarkText);
    put(I.CustObs, custObs);
    put(I.PaymentsJson, paymentsJson);
    put(I.PayloadJson, payloadJson);

    if (existing) {
      sh.getRange(existing.row,1,1,row.length).setValues([row]);
      return { success:true, updated:true, serviceNo };
    }
    sh.appendRow(row);
    return { success:true, inserted:true, serviceNo };
  }catch(err){
    return { success:false, message:String(err) };
  }
}

function serviceHistoryRowToObj_(r, I){
  const payloadRaw = safeJson_(r[I.PayloadJson]) || {};
  const payments = safeJson_(r[I.PaymentsJson]) || [];
  const regNo = r[I.RegNo] || '';
  const jcNo = r[I.JCNo] || '';
  const mobile = r[I.Mobile] || '';
  const serviceType = r[I.ServiceType] || '';
  const company = (I.Company >= 0 ? r[I.Company] : '') || '';
  const chassisNo = (I.ChassisNo >= 0 ? r[I.ChassisNo] : '') || '';
  const model = r[I.Model] || '';
  const colour = r[I.Colour] || '';
  const branch = r[I.Branch] || '';
  const mechanic = r[I.Mechanic] || '';
  const executive = r[I.Executive] || '';
  const serviceNo = Number(r[I.ServiceNo] || '') || null;
  const createdAt = r[I.PostAt] || r[I.CreatedAt] || '';
  const remarks = r[I.Remarks] || '';
  const amount = r[I.CollectedAmount] || r[I.TotalsGrand] || '';
  const paymentMode = r[I.PaymentMode] || '';

  const totals = payloadRaw.totals || {};
  if (!totals.grand && amount) totals.grand = Number(amount) || amount;
  payloadRaw.totals = totals;
  payloadRaw.payments = payloadRaw.payments || payments;
  const fv = payloadRaw.formValues || {};
  payloadRaw.formValues = Object.assign({}, fv, {
    regNo,
    jcNo,
    serviceType,
    company,
    chassisNo,
    model,
    colour,
    branch,
    mechanic,
    executive,
    paymentMode,
    custMobile: mobile,
    createdAt,
    serviceNo
  });
  payloadRaw.serviceNo = serviceNo;

  return {
    jcNo,
    regNo,
    mobile,
    serviceType,
    model,
    colour,
    branch,
    mechanic,
    executive,
    amount,
    paymentMode,
    serviceNo,
    createdAt,
    remarks,
    totals,
    payments,
    payload: payloadRaw,
    values: {
      'JC No': jcNo,
      'Vehicle No': regNo,
      'Registration Number': regNo,
      'Chassis No': chassisNo,
      'Service Type': serviceType,
      'Company': company,
      'Model': model,
      'Colour': colour,
      'Branch': branch,
      'Mechanic': mechanic,
      'Executive': executive,
      'Payment Mode': paymentMode,
      'Collected Amount': amount,
      'Created At': createdAt,
      'Remark Text': remarks,
      'Service No': serviceNo,
    }
  };
}

function getServiceHistory_(params){
  const q = String(params && (params.query || params.regNo || params.vehicle || params.mobile || params.number) || '').trim();
  if (!q) return { success:false, message:'query (vehicle or mobile) is required' };
  const regQ = normReg_(q);
  const mobileQ = ten_(q);
  const sh = serviceHistorySheet_();
  const width = Math.max(sh.getLastColumn(), SERVICE_HISTORY_HEADERS.length);
  const headers = sh.getRange(1,1,1,width).getValues()[0];
  const I = serviceHistoryIx_(headers);
  const last = sh.getLastRow();
  if (last <= 1) return { success:true, rows: [] };
  const rows = sh.getRange(2,1,last-1,I.width).getValues();
  const matches = rows
    .filter(r => {
      const regMatch = regQ ? normReg_(r[I.RegNo]) === regQ : false;
      const mobileMatch = mobileQ ? ten_(r[I.Mobile]) === mobileQ : false;
      return regMatch || mobileMatch;
    })
    .map(r => serviceHistoryRowToObj_(r, I))
    .sort((a,b) => {
      const ta = a.createdAt ? new Date(a.createdAt).getTime() : 0;
      const tb = b.createdAt ? new Date(b.createdAt).getTime() : 0;
      if (ta !== tb) return ta - tb;
      const sa = Number(a.serviceNo || 0);
      const sb = Number(b.serviceNo || 0);
      return sa - sb;
    });
  return { success:true, rows: matches };
}

/** Upsert by JC No (fallback to mobile if JC is missing). */
function upsertByMobile_(d){
  const lock = LockService.getScriptLock();
  try {
    lock.waitLock(30000);
  } catch (e) {
    return { success:false, message:'lock_timeout' };
  }
  try {
    const s = sh_();
    ensureCoreOptionalCols_(s);
    let ix = headerIx_(s);

  const fvIncoming = canonicalFormValues_(d);
  const jcIncoming = String(
    d.jcNo ||
    fvIncoming.jcNo ||
    (d.payload && d.payload.formValues && d.payload.formValues.jcNo) ||
    ''
  ).trim();
  const mobile10 = ten_(d.mobile || fvIncoming.custMobile);
  const last = s.getLastRow();
  let hitRow = -1;
  let existingRow = null;
  if (last > 1) {
    const rows = s.getRange(2,1,last-1,ix.width).getValues();
    if (jcIncoming && ix.idxJC >= 0) {
      for (let i = rows.length - 1; i >= 0; i--) {
        const jc = String(rows[i][ix.idxJC] || '').trim();
        if (jc && jc === jcIncoming) { hitRow = i + 2; existingRow = rows[i]; break; }
      }
    }
    if (hitRow < 0 && !jcIncoming && mobile10 && ix.idxMobile >= 0) {
      for (let i = rows.length - 1; i >= 0; i--) {
        const m = ten_(rows[i][ix.idxMobile]);
        if (m === mobile10) { hitRow = i + 2; existingRow = rows[i]; break; }
      }
    }
  }

  if (hitRow < 0) {
    return insertNew_(Object.assign({}, d, { formValues: fvIncoming, payload: d.payload || d }), mobile10);
  }

  const existingPayload = (existingRow && ix.idxPayloads.length) ? safeJson_(existingRow[ix.idxPayloads[0]]) : null;
  const existingFv = existingPayload && existingPayload.formValues ? existingPayload.formValues : {};
  const fv = Object.assign({}, existingFv || {}, fvIncoming || {});

  const put = (row, i, v) => { if (i >= 0 && v !== undefined && v !== null && String(v) !== '') row[i] = v; };

  let mergedPayload = {};
  if (existingPayload && typeof existingPayload === 'object') mergedPayload = JSON.parse(JSON.stringify(existingPayload));
  if (d.payload && typeof d.payload === 'object') mergedPayload = mergeObj_(mergedPayload, d.payload);
  mergedPayload.formValues = Object.assign({}, existingFv || {}, fvIncoming || {});
  mergedPayload = cleanPayload_(mergedPayload, fv);
  const updatedAt = mergedPayload.updatedAt || d.updatedAt || (d.payload && d.payload.updatedAt) || '';

  const postAt = (mergedPayload && mergedPayload.postServiceAt) ? mergedPayload.postServiceAt : (d?.payload?.postServiceAt || '');
  const utr = String(d && (d.utr || d.utrNo || (d.payload && (d.payload.utr || d.payload.utrNo)) || '')).trim();

  const row = s.getRange(hitRow,1,1,ix.width).getValues()[0];

  put(row, ix.idxTime, new Date());
  put(row, ix.idxName, fv.custName);
  put(row, ix.idxMobile, mobile10);
  put(row, ix.idxAmount, (d.collectedAmount != null ? d.collectedAmount : fv.amount));
  put(row, ix.idxReg, fv.regNo);
  put(row, ix.idxSvc, fv.serviceType);
  put(row, ix.idxBranch, fv.branch);
  put(row, ix.idxObs, fv.obs);
  put(row, ix.idxExp, fv.expectedDelivery);
  put(row, ix.idxPayment, (d.paymentMode != null ? d.paymentMode : fv.paymentMode));

  put(row, ix.idxExecutive2, fv.executive);
  put(row, ix.idxMechanic, fv.mechanic);
  put(row, ix.idxCompany, fv.company);
  put(row, ix.idxChassis, fv.chassisNo || fv.chassis);
  put(row, ix.idxModel, fv.model);
  put(row, ix.idxColour, fv.colour);
  put(row, ix.idxKM, digitsOnly_(fv.km));
  put(row, ix.idxFuel, fv.fuelLevel);
  put(row, ix.idxVehType, fv.vehicleType);

  put(row, ix.idxPostAt, postAt);
  put(row, ix.idxUTR, utr);
  put(row, ix.idxUpdatedAt, updatedAt);

  if (ix.idxJC >= 0 && (d.jcNo || fv.jcNo)) row[ix.idxJC] = (d.jcNo || fv.jcNo);

  if (ix.idxPayloads.length) row[ix.idxPayloads[0]] = JSON.stringify(mergedPayload);

    s.getRange(hitRow,1,1,ix.width).setValues([row]);
    return { success:true, upsert:true, updated:true, row: hitRow };
  } finally {
    try { lock.releaseLock(); } catch (_) {}
  }
}

function insertNew_(d, mobileCanonical){
  const s = sh_();
  ensureCoreOptionalCols_(s);
  let ix = headerIx_(s);

  const fv = canonicalFormValues_(d);
  const serial = String(fv.jcNo || nextSerial_());
  const mobile10 = mobileCanonical || ten_(fv.custMobile);

  const put = (row, i, v) => { if (i >= 0) row[i] = (v === undefined || v === null) ? '' : v; };

  const postAt = (d && d.payload && d.payload.postServiceAt) ? d.payload.postServiceAt : '';
  const utr = String(d && (d.utr || d.utrNo || (d.payload && (d.payload.utr || d.payload.utrNo)) || '')).trim();

  const row = new Array(ix.width).fill('');
  put(row, ix.idxTime, new Date());
  put(row, ix.idxName, fv.custName || '');
  put(row, ix.idxMobile, mobile10 || '');
  put(row, ix.idxAmount, (d.collectedAmount != null ? d.collectedAmount : fv.amount) || '');
  put(row, ix.idxReg, fv.regNo || '');
  put(row, ix.idxSvc, fv.serviceType || '');
  put(row, ix.idxBranch, fv.branch || '');
  put(row, ix.idxObs, fv.obs || '');
  put(row, ix.idxExp, fv.expectedDelivery || '');
  put(row, ix.idxPayment, (d.paymentMode != null ? d.paymentMode : fv.paymentMode) || '');

  put(row, ix.idxExecutive2, fv.executive || '');
  put(row, ix.idxMechanic, fv.mechanic || '');
  put(row, ix.idxCompany, fv.company || '');
  put(row, ix.idxChassis, fv.chassisNo || fv.chassis || '');
  put(row, ix.idxModel, fv.model || '');
  put(row, ix.idxColour, fv.colour || '');
  put(row, ix.idxKM, digitsOnly_(fv.km || ''));
  put(row, ix.idxFuel, fv.fuelLevel || '');
  put(row, ix.idxVehType, fv.vehicleType || '');

  put(row, ix.idxPostAt, postAt || '');
  put(row, ix.idxUTR, utr || '');

  const payloadToStore = (function(){
    const base = (d && d.payload && typeof d.payload === 'object') ? d.payload : {};
    const merged = mergeObj_({ formValues: {} }, base);
    merged.formValues = Object.assign({}, fv || {});
    return cleanPayload_(merged, fv);
  })();
  if (ix.idxPayloads.length) row[ix.idxPayloads[0]] = JSON.stringify(payloadToStore);
  put(row, ix.idxUpdatedAt, payloadToStore.updatedAt || d.updatedAt || '');

  put(row, ix.idxJC, serial);

  s.appendRow(row);
  return { success:true, upsert:true, row: s.getLastRow(), jcNo: serial };
}

/* === NEW: fetch full existing row & payload for delta DC logic === */
function findExistingRowFull_(mobile10, jcNo){
  try{
    const s = sh_();
    const ix = headerIx_(s);
    const last = s.getLastRow();
    if (last <= 1) return null;

    const rows = s.getRange(2,1,last-1,ix.width).getValues();
  if (jcNo && ix.idxJC >= 0) {
      for (let i = rows.length - 1; i >= 0; i--){
        const r = rows[i];
        const jc = String(r[ix.idxJC] || '').trim();
        if (jc && jc === jcNo){
          const payload = ix.idxPayloads.length ? safeJson_(r[ix.idxPayloads[0]]) : null;
          return { rowIndex: i+2, rowValues: r, payload, ix };
        }
      }
    }
    if (!jcNo && mobile10 && ix.idxMobile >= 0) {
      for (let i = rows.length - 1; i >= 0; i--){
        const r = rows[i];
        const m = ten_(r[ix.idxMobile]);
        if (m === mobile10){
          const payload = ix.idxPayloads.length ? safeJson_(r[ix.idxPayloads[0]]) : null;
          return { rowIndex: i+2, rowValues: r, payload, ix };
        }
      }
    }
    return null;
  }catch(_){ return null; }
}

/* === helper to fetch branch + executive from existing sheet row === */
function findExistingBranchExec_(mobile10, jcNo) {
  try {
    const s = sh_();
    const ix = headerIx_(s);
    const last = s.getLastRow();
    if (last <= 1) return { branch: '', executive: '' };

    const rows = s.getRange(2,1,last-1,ix.width).getValues();
    let hit = -1;
    if (jcNo && ix.idxJC >= 0) {
      for (let i = rows.length - 1; i >= 0; i--) {
        const r = rows[i];
        const jc = String(r[ix.idxJC] || '').trim();
        if (jc && jc === jcNo) { hit = i; break; }
      }
    }
    if (hit < 0 && mobile10 && ix.idxMobile >= 0) {
      for (let i = rows.length - 1; i >= 0; i--) {
        const r = rows[i];
        const m = String(r[ix.idxMobile] || '').replace(/\D/g,'').slice(-10);
        if (m === mobile10) { hit = i; break; }
      }
    }
    if (hit < 0) return { branch: '', executive: '' };

    const r = rows[hit];
    let branch = String(r[ix.idxBranch] || '').trim();
    let executive = ix.idxExecutive2 >= 0 ? String(r[ix.idxExecutive2] || '').trim() : '';

    if (!branch || !executive) {
      const payload = ix.idxPayloads.length ? safeJson_(r[ix.idxPayloads[0]]) : null;
      if (!branch)    branch    = String(payload?.formValues?.branch    || '').trim();
      if (!executive) executive = String(payload?.formValues?.executive || '').trim();
    }
    return { branch, executive };
  } catch (_) { 
    return { branch: '', executive: '' }; 
  }
}

// save (pre-service) → upsert by mobile
function save_(d){
  return upsertByMobile_({ ...d, payload: d.payload || d });
}

// postService → upsert by mobile with amount/payment overrides + DailyCollections update
function postService_(d){
  const amount = computeAmount_(d);
  const mode = computeMode_(d);

  const nowIso = new Date().toISOString();
  const payload0 = (d.payload && typeof d.payload === 'object') ? d.payload : {};
  if (!payload0.postServiceAt) payload0.postServiceAt = nowIso;

  const mobile10 =
    String(d.mobile || d?.formValues?.custMobile || d?.payload?.formValues?.custMobile || '')
      .replace(/\D/g,'')
      .slice(-10);
  const jcNo = String(d.jcNo || d?.formValues?.jcNo || d?.payload?.formValues?.jcNo || '').trim();

  // ✅ NEW: grab previous service amount & logged-state BEFORE update
  const existingFull = findExistingRowFull_(mobile10, jcNo);
  const prevPayload = existingFull?.payload || {};
  const prevAmt = Number(prevPayload?.postServiceAmount || existingFull?.rowValues?.[existingFull.ix.idxAmount] || 0) || 0;
  const alreadyLogged = prevPayload?.postServiceLogged === true;

  const fv0 = canonicalFormValues_(d);
  let branch    = fv0.branch    || d?.payload?.formValues?.branch    || '';
  let executive = fv0.executive || d?.payload?.formValues?.executive || '';

  if ((!branch || !executive) && (mobile10 || jcNo)) {
    const got = findExistingBranchExec_(mobile10, jcNo);
    if (!branch)    branch    = got.branch;
    if (!executive) executive = got.executive;
  }

  const fv = {
    ...fv0,
    branch,
    executive,
    amount: (amount > 0 ? amount : fv0.amount),
    paymentMode: (mode || fv0.paymentMode || ''),
    jcNo: jcNo || fv0.jcNo
  };

  // ✅ NEW: store flags so next postservice won't double count
  payload0.postServiceLogged = true;
  payload0.postServiceAmount = amount;
  payload0.postServiceMode = mode;

  // 1) Save/update main Job Card row
  const result = upsertByMobile_({
    ...d,
    collectedAmount: amount,
    paymentMode: mode,
    formValues: fv,
    payload: payload0
  });

  // 1b) Append to ServiceHistory (jcNo idempotent)
  try {
    upsertServiceHistory_({
      ...d,
      formValues: fv,
      payload: payload0,
      totals: { ...(d.totals || {}), grand: amount },
      collectedAmount: amount,
      postServiceAt: payload0.postServiceAt || nowIso
    });
  } catch (_){}

  // 2) Update DailyCollections for this JC amount (with split)
  try {
    const b = String(fv.branch || '').trim();
    const s = String(fv.executive || '').trim();
    const newAmt = Number(amount || 0);

    // ✅ NEW: delta logic
    const deltaAmt = alreadyLogged ? Math.max(0, newAmt - prevAmt) : newAmt;
    if (!(deltaAmt > 0)) return result; // nothing extra to log

    let cashCollected = Number(d.cashCollected || 0) || 0;
    let onlineCollected = Number(d.onlineCollected || 0) || 0;

    if (!(cashCollected > 0) && !(onlineCollected > 0) && Array.isArray(d.payments)) {
      cashCollected = d.payments
        .filter(p => String(p.mode||'').toLowerCase()==='cash')
        .reduce((sum,p)=> sum + (Number(p.amount)||0), 0);
      onlineCollected = d.payments
        .filter(p => String(p.mode||'').toLowerCase()==='online')
        .reduce((sum,p)=> sum + (Number(p.amount)||0), 0);
    }

    if (!(cashCollected > 0) && !(onlineCollected > 0) && deltaAmt > 0) {
      if (mode === 'cash') cashCollected = deltaAmt;
      else if (mode === 'online') onlineCollected = deltaAmt;
      else cashCollected = deltaAmt;
    }

    if (b && s && deltaAmt > 0) {
      const ledgerCtx = {
        sourceType: 'jc',
        sourceId: jcNo,
        jcNo: jcNo,
        customerName: fv.custName || fv.customerName || '',
        customerMobile: mobile10,
        paymentMode: mode || fv.paymentMode || '',
        payments: Array.isArray(d.payments) ? d.payments : undefined,
        utr: String(d.utr || d.utrNo || (d.payload && (d.payload.utr || d.payload.utrNo)) || '').trim()
      };
      updateDailyCollection_(b, s, deltaAmt, 'jc', { cashCollected, onlineCollected, staffLedgerContext: ledgerCtx });
    }
  } catch (err) {}

  return result;
}

// Produce a normalized object for one sheet row
function toRowObject_(row, ix){
  const payload = ix.idxPayloads.length ? safeJson_(row[ix.idxPayloads[0]]) : null;

  const levelFromCols = (ix.idxRemarkLevel >= 0) ? String(row[ix.idxRemarkLevel] || '') : '';
  const textFromCols = (ix.idxRemarkText >= 0) ? String(row[ix.idxRemarkText] || '') : '';
  const remarkLevel = levelFromCols;
  const remarkText = textFromCols;

  return {
    values: {
      Timestamp: row[ix.idxTime],
      Customer_Name: row[ix.idxName],
      Mobile: row[ix.idxMobile],
      Collected_Amount: row[ix.idxAmount],
      Vehicle_No: row[ix.idxReg],
      Service_Type: row[ix.idxSvc],
      Branch: row[ix.idxBranch],
      Customer_Observation: row[ix.idxObs],
      Expected_Delivery_Date: row[ix.idxExp],
      Payment_Mode: ix.idxPayment >= 0 ? row[ix.idxPayment] : '',
      'JC No.': row[ix.idxJC],
      RemarkLevel: remarkLevel || '',
      RemarkText: remarkText || '',
      Executive: ix.idxExecutive2 >= 0 ? row[ix.idxExecutive2] : '',
      'Allotted Mechanic': ix.idxMechanic >= 0 ? row[ix.idxMechanic] : '',
      Allotted_Mechanic: ix.idxMechanic >= 0 ? row[ix.idxMechanic] : '',
      Company: ix.idxCompany >= 0 ? row[ix.idxCompany] : '',
      'Chassis No': ix.idxChassis >= 0 ? row[ix.idxChassis] : '',
      Chassis_No: ix.idxChassis >= 0 ? row[ix.idxChassis] : '',
      Model: ix.idxModel >= 0 ? row[ix.idxModel] : '',
      Color: ix.idxColour >= 0 ? row[ix.idxColour] : '',
      Colour: ix.idxColour >= 0 ? row[ix.idxColour] : '',
      'Odometer Reading': ix.idxKM >= 0 ? row[ix.idxKM] : '',
      KM: ix.idxKM >= 0 ? row[ix.idxKM] : '',
      'Fuel Level': ix.idxFuel >= 0 ? row[ix.idxFuel] : '',
      Fuel_Level: ix.idxFuel >= 0 ? row[ix.idxFuel] : '',
      'Vehicle Type': ix.idxVehType >= 0 ? row[ix.idxVehType] : '',
      Vehicle_Type: ix.idxVehType >= 0 ? row[ix.idxVehType] : '',
      'Post Service At': ix.idxPostAt >= 0 ? row[ix.idxPostAt] : '',
      Post_Service_At: ix.idxPostAt >= 0 ? row[ix.idxPostAt] : '',
      'UTR No': ix.idxUTR >= 0 ? row[ix.idxUTR] : '',
      UTR_No: ix.idxUTR >= 0 ? row[ix.idxUTR] : '',
    },
    payload
  };
}

// Search by JC or Mobile
function search_(mode, query){
  const s = sh_();
  const ix = ensureRemarkCols_(s, headerIx_(s));
  const last = s.getLastRow();
  if (last <= 1) return [];

  const rows = s.getRange(2,1,last-1,ix.width).getValues();
  const q = String(query || '').trim();
  const q10 = ten_(q);
  const qReg = normReg_(q);

  const out = [];
  for (let i = 0; i < rows.length; i++) {
    const r = rows[i];
    const payload = ix.idxPayloads.length ? safeJson_(r[ix.idxPayloads[0]]) : null;

    let match = false;
    if (mode === 'mobile') {
      const m = ten_(r[ix.idxMobile]);
      match = q10 ? (q10.length < 10 ? m.endsWith(q10) : (m === q10)) : false;
    } else if (mode === 'reg' || mode === 'vehicle') {
      const regSheet = ix.idxReg >= 0 ? normReg_(r[ix.idxReg]) : '';
      const regPayload = normReg_(payload && (
        payload.regNo ||
        payload.vehicleNo ||
        (payload.formValues && payload.formValues.regNo) ||
        (payload.formValues && payload.formValues.vehicleNo) ||
        (payload.vehicle && payload.vehicle.regNo) ||
        (payload.vehicle && payload.vehicle.registrationNumber)
      ));
      match = qReg ? (regSheet === qReg || regPayload === qReg) : false;
    } else {
      match = String(r[ix.idxJC] || '').trim() === q;
    }
    if (!match) continue;

    out.push(toRowObject_(r, ix));
  }
  return out;
}

/* ============================
Follow-up listing + updates
============================ */

function startOfToday_(){
  const d = new Date();
  d.setHours(0,0,0,0);
  return d;
}
function endOfToday_(){
  const d = new Date();
  d.setHours(23,59,59,999);
  return d;
}
function isValidDate_(d){ return d && Object.prototype.toString.call(d) === '[object Date]' && !isNaN(d.getTime()); }

function followups_(filter, branch, executive){
  const s = sh_();
  const ix = headerIx_(s);
  const last = s.getLastRow();
  if (last <= 1) return { success:true, rows: [] };

  const rows = s.getRange(2,1,last-1,ix.width).getValues();
  const t0 = startOfToday_().getTime();
  const t1 = endOfToday_().getTime();

  const want = String(filter || 'today').toLowerCase();
  const wantBranchKey = norm_(branch);
  const wantExecKey = norm_(executive);

  const out = [];
  for (let i = 0; i < rows.length; i++) {
    const r = rows[i];
    const jc = String(r[ix.idxJC] || '').trim();
    if (!jc) continue;

    const payload = ix.idxPayloads.length ? safeJson_((r[ix.idxPayloads[0]] || '{}')) : null;
    const fu = payload && payload.followUp ? payload.followUp : null;
    if (!fu || fu.enabled === false) continue;

    const at = fu.at ? new Date(fu.at) : null;
    const t = isValidDate_(at) ? at.getTime() : null;

    const rowBranch = String((ix.idxBranch >= 0 ? r[ix.idxBranch] : '') || fu.branch || '').trim();
    const execPayload = payload && payload.formValues ? String(payload.formValues.executive || '') : '';
    const rowExec = String((ix.idxExecutive2 >= 0 ? r[ix.idxExecutive2] : '') || execPayload || fu.assignedTo || '').trim();

    if (wantBranchKey && norm_(rowBranch) !== wantBranchKey) continue;
    if (wantExecKey && norm_(rowExec) !== wantExecKey) continue;

    let datePass = true;
    if (want !== 'all') {
      if (!t) datePass = false;
      else if (want === 'today') datePass = (t >= t0 && t <= t1);
      else if (want === 'overdue') datePass = (t < t0);
      else if (want === 'upcoming')datePass = (t > t1);
    }
    if (!datePass) continue;

    const fvFromSheet = {
      name: String(r[ix.idxName] || '').trim(),
      mobile: String(r[ix.idxMobile] || '').trim(),
      branch: rowBranch,
      jcNo: jc,
      model: payload && payload.formValues ? (payload.formValues.model || '') : '',
      bikeModel: payload && payload.formValues ? (payload.formValues.model || '') : '',
      executive: rowExec,
    };

    out.push({
      formValues: fvFromSheet,
      followUp: {
        enabled: (fu.enabled !== false),
        at: fu.at || null,
        notes: fu.notes || '',
        assignedTo: rowExec || '',
        branch: rowBranch || '',
        customer: fu.customer || { name: fvFromSheet.name, mobile: fvFromSheet.mobile },
        status: fu.status || 'pending',
      },
      brand: (payload && payload.brand) ? payload.brand : '',
    });
  }

  out.sort((a,b) => {
    const ta = a.followUp.at ? new Date(a.followUp.at).getTime() : 0;
    const tb = b.followUp.at ? new Date(b.followUp.at).getTime() : 0;
    return tb - ta;
  });

  return { success:true, rows: out };
}

function mergeObj_(target, src){
  if (!src || typeof src !== 'object') return target || {};
  if (!target || typeof target !== 'object') target = {};
  Object.keys(src).forEach(k => {
    const v = src[k];
    if (v && typeof v === 'object' && !Array.isArray(v)) {
      target[k] = mergeObj_(target[k], v);
    } else {
      target[k] = v;
    }
  });
  return target;
}

function updateFollowup_(serialNo, patch){
  if (!serialNo) return { success:false, message:'serialNo is required' };
  const s = sh_();
  const ix = headerIx_(s);
  if (ix.idxJC < 0) return { success:false, message:'JC column not found' };
  if (!ix.idxPayloads.length) return { success:false, message:'Payload column not found' };

  const last = s.getLastRow();
  if (last <= 1) return { success:false, message:'No data' };

  const rows = s.getRange(2,1,last-1,ix.width).getValues();
  let hit = -1;
  for (let i = rows.length - 1; i >= 0; i--) {
    const jc = String(rows[i][ix.idxJC] || '').trim();
    if (jc === String(serialNo).trim()) { hit = i + 2; break; }
  }
  if (hit < 0) return { success:false, message:'Not found' };

  const row = s.getRange(hit,1,1,ix.width).getValues()[0];
  const cur = safeJson_(row[ix.idxPayloads[0]]) || {};
  cur.followUp = mergeObj_(cur.followUp || {}, (patch && patch.followUp) || {});
  if (typeof patch?.status !== 'undefined') cur.followUp.status = patch.status;
  if (cur.followUp && typeof cur.followUp.enabled === 'undefined') cur.followUp.enabled = true;
  if (patch && patch.followUp && typeof patch.followUp === 'object') {
    if (typeof patch.followUp.branch !== 'undefined') {
      if (ix.idxBranch >= 0) row[ix.idxBranch] = String(patch.followUp.branch || '');
    }
    if (typeof patch.followUp.assignedTo !== 'undefined') {
      if (ix.idxExecutive2 >= 0) row[ix.idxExecutive2] = String(patch.followUp.assignedTo || '');
    }
  }

  row[ix.idxPayloads[0]] = JSON.stringify(cleanPayload_(cur, {}));
  s.getRange(hit,1,1,ix.width).setValues([row]);
  return { success:true, updated:true, row: hit };
}

function list_(opts) {
  const s = sh_();
  let ix = ensureRemarkCols_(s, headerIx_(s));
  const last = s.getLastRow();
  if (last <= 1) return compat_({ ok: true, data: [], total: 0 });
  const rows = s.getRange(2,1,last-1,ix.width).getValues();

  const wantBranchKey = norm_(String((opts && opts.branch) || ''));
  const wantExecKey = norm_(String((opts && opts.executive) || ''));
  const wantService = String((opts && opts.service) || '').toLowerCase();
  const wantStatus = String((opts && opts.status) || '').toLowerCase();
  const q = String((opts && opts.q) || '').trim();

  const startMs = (opts && typeof opts.startMs === 'number') ? opts.startMs : null;
  const endMs = (opts && typeof opts.endMs === 'number') ? opts.endMs : null;
  const sinceISO = (opts && opts.sinceISO) ? String(opts.sinceISO) : '';
  const untilISO = (opts && opts.untilISO) ? String(opts.untilISO) : '';

  const page = Math.max(parseInt((opts && opts.page) || '1', 10) || 1, 1);
  const pageSize = Math.min(100, Math.max(0, parseInt((opts && opts.pageSize) || '0', 10) || 0));
  const limit = Math.max(parseInt((opts && opts.limit) || '0', 10) || 0, 0);

  const enriched = rows.map((r) => {
    const payload = ix.idxPayloads.length ? safeJson_(r[ix.idxPayloads[0]]) : null;

    const t = r[ix.idxTime];
    const savedAtRaw =
      (payload && (payload.savedAt || payload.createdAt || payload.ts || payload.timestamp)) ||
      (payload && payload.formValues && (payload.formValues.savedAt || payload.formValues.createdAt || payload.formValues.timestamp)) ||
      '';
    let tsMs = 0;
    if (savedAtRaw) {
      const d = new Date(String(savedAtRaw));
      if (!isNaN(d.getTime())) tsMs = d.getTime();
    }
    if (!tsMs) {
      if (t instanceof Date) tsMs = t.getTime();
      else if (t) { const d = new Date(String(t)); if (!isNaN(d.getTime())) tsMs = d.getTime(); }
    }

    const rowBranch = String(r[ix.idxBranch] || '').trim();
    const execFromSheet = String((ix.idxExecutive2 >= 0 ? r[ix.idxExecutive2] : '') || '').trim();
    const execFromPayload = String((payload && payload.formValues && payload.formValues.executive) || '').trim();
    const branchPayload = String((payload && payload.formValues && payload.formValues.branch) || '').trim();
    const paymentMode = ix.idxPayment >= 0 ? String(r[ix.idxPayment] || '') : '';
    const postAt = (payload && payload.postServiceAt) || (ix.idxPostAt >= 0 ? r[ix.idxPostAt] : '') || '';
    const hasPost = String(postAt || '').trim().length > 0;
    const hasPayments = Array.isArray(payload && payload.payments) && payload.payments.some(function(p){ return Number(p && p.amount || 0) > 0; });
    const hasPaymentMode = String(paymentMode || '').trim().length > 0;
    const amt = ix.idxAmount >= 0 ? r[ix.idxAmount] : '';
    const hasAmount = String(amt || '').trim().length > 0;
    const status = (hasPost || hasPayments || (hasPaymentMode && hasAmount)) ? 'completed' : 'pending';
    const model = String((ix.idxModel >= 0 ? r[ix.idxModel] : '') || (payload && payload.formValues ? payload.formValues.model : '') || '').trim();
    const company = String((ix.idxCompany >= 0 ? r[ix.idxCompany] : '') || (payload && payload.formValues ? payload.formValues.company : '') || '').trim();

    return {
      raw: r,
      payload,
      tsMs,
      name: String(r[ix.idxName] || ''),
      mobile: String(r[ix.idxMobile] || ''),
      regNo: String(r[ix.idxReg] || ''),
      serviceType: String(r[ix.idxSvc] || '').toLowerCase(),
      branchSheet: rowBranch,
      branchPayload,
      executive: execFromSheet || execFromPayload,
      paymentMode,
      jcNo: String(r[ix.idxJC] || '').trim(),
      company,
      model,
      status
    };
  });

  let filtered = enriched.filter((x) => {
    if (wantBranchKey) {
      const b1 = norm_(x.branchSheet);
      const b2 = norm_(x.branchPayload);
      if (!(b1 === wantBranchKey || b2 === wantBranchKey)) return false;
    }
    if (wantExecKey && norm_(x.executive) !== wantExecKey) return false;
    if (wantService && x.serviceType !== wantService) return false;
    if (wantStatus && x.status !== wantStatus) return false;

    if (startMs && endMs) {
      if (!x.tsMs || x.tsMs < startMs || x.tsMs > endMs) return false;
    } else if (sinceISO || untilISO) {
      const since = sinceISO ? new Date(sinceISO) : null;
      const until = untilISO ? new Date(untilISO) : null;
      if (since && (!x.tsMs || x.tsMs < since.getTime())) return false;
      if (until && (!x.tsMs || x.tsMs > until.getTime())) return false;
    }

    if (q) {
      const hay = [x.name, x.mobile, x.jcNo, x.regNo, x.model, x.company, x.branchSheet, x.branchPayload, x.executive, x.paymentMode];
      let hit = false;
      for (var i=0;i<hay.length;i++){ if (norm_(hay[i]).indexOf(norm_(q)) !== -1) { hit = true; break; } }
      if (!hit) return false;
    }
    return true;
  });

  filtered.sort((a,b) => (b.tsMs||0)-(a.tsMs||0));

  const total = filtered.length;
  let slice;
  if (pageSize > 0) {
    const start = (page - 1) * pageSize;
    slice = filtered.slice(start, start + pageSize);
  } else if (limit > 0) {
    const start = (page - 1) * limit;
    slice = filtered.slice(start, start + limit);
  } else {
    slice = filtered;
  }

  ix = headerIx_(s); // refresh in case columns were added above
  const data = slice.map(x => toRowObject_(x.raw, ix));
  return compat_({ ok: true, data, rows: data, total });
}

function compat_(obj) {
  const out = obj || {};
  if (typeof out.success === 'undefined') out.success = true;
  if (!Array.isArray(out.rows) && Array.isArray(out.data)) out.rows = out.data;
  return out;
}

/* ============================
Remarks (Payload.remark + optional columns)
============================ */
function updateRemark_(jcNo, level, text, by) {
  if (!jcNo) return { success:false, message:'jcNo is required' };
  var lv = String(level || '').toLowerCase();
  if (!/(^ok$|^warning$|^alert$)/.test(lv)) return { success:false, message:'level must be ok|warning|alert' };

  var s = sh_();
  var ix = headerIx_(s);
  if (ix.idxJC < 0) return { success:false, message:'JC column not found' };
  if (!ix.idxPayloads.length) return { success:false, message:'Payload column not found' };

  var last = s.getLastRow();
  if (last <= 1) return { success:false, message:'No data' };

  var rows = s.getRange(2,1,last-1,ix.width).getValues();
  var hit = -1;
  for (var i = rows.length - 1; i >= 0; i--) {
    var jc = String(rows[i][ix.idxJC] || '').trim();
    if (jc === String(jcNo).trim()) { hit = i + 2; break; }
  }
  if (hit < 0) return { success:false, message:'Not found' };

  var row = s.getRange(hit,1,1,ix.width).getValues()[0];
  var payload = safeJson_(row[ix.idxPayloads[0]]) || {};
  row[ix.idxPayloads[0]] = JSON.stringify(cleanPayload_(payload, {}));

  var info = ensureRemarkCols_(s, headerIx_(s));
  var rl = info.idxRemarkLevel;
  var rt = info.idxRemarkText;

  if (rl >= 0) row[rl] = lv.toUpperCase();
  if (rt >= 0) row[rt] = String(text || '').slice(0, 240);

  var width = Math.max(info.width, row.length);
  s.getRange(hit,1,1,width).setValues([row]);

  return { success:true, updated:true, row: hit, jcNo: jcNo, level: lv, text: String(text || '') };
}

/* ============== DAILY COLLECTIONS MODULE (MASTER) ============== */
function dcTodayStrIndia_() {
  const tz = Session.getScriptTimeZone() || 'Asia/Kolkata';
  return Utilities.formatDate(new Date(), tz, 'yyyy-MM-dd');
}
function dcTsIndia_() {
  const tz = Session.getScriptTimeZone() || 'Asia/Kolkata';
  return Utilities.formatDate(new Date(), tz, "yyyy-MM-dd'T'HH:mm:ss.SSSXXX");
}
function dcToNum_(x) {
  const n = Number(x || 0);
  return isNaN(n) ? 0 : n;
}

function dcGetSheet_() {
  const masterId = typeof DC_MASTER_SPREADSHEET_ID === 'string'
    ? DC_MASTER_SPREADSHEET_ID
    : '';
  const ss = masterId
    ? SpreadsheetApp.openById(masterId)
    : (SHEET_ID ? SpreadsheetApp.openById(SHEET_ID) : SpreadsheetApp.getActiveSpreadsheet());

  let sh = ss.getSheetByName(DC_SHEET);
  if (!sh) sh = ss.insertSheet(DC_SHEET);

  const w = Math.max(sh.getLastColumn(), DC_HEADERS.length);
  const first = sh.getRange(1,1,1,w).getValues()[0];
  const lastRow = sh.getLastRow();
  const a1 = String(first[0] || '').trim();
  const looksLikeHint = /^type "@dropdown"/i.test(a1);

  if (lastRow === 0 || (lastRow === 1 && (!a1 || looksLikeHint))) {
    sh.clear();
    sh.getRange(1,1,1,DC_HEADERS.length).setValues([DC_HEADERS]);
  }

  return sh;
}

function dcFindCol_(headers, names) {
  // Trim + case-insensitive match for robustness
  const norm = (s) => String(s||'').trim().toLowerCase();
  const H = headers.map(norm);
  for (var i=0;i<names.length;i++) {
    var j = H.indexOf(norm(names[i]));
    if (j >= 0) return j;
  }
  return -1;
}

function dcIdx_(headers) {
  return {
    Date:   dcFindCol_(headers, ['Date']),
    Branch: dcFindCol_(headers, ['Branch']),
    Staff:  dcFindCol_(headers, ['Staff']),
    Booking: dcFindCol_(headers, ['Booking Amount']),
    JC:      dcFindCol_(headers, ['JC Amount']),
    Minor:   dcFindCol_(headers, ['Minor Sales Amount','Minor Sales Amt']),
    Total:   dcFindCol_(headers, ['Total']),
    Cash:    dcFindCol_(headers, ['Cash Amount']),
    Online:  dcFindCol_(headers, ['Online Amount']),
    TotalCollected: dcFindCol_(headers, ['Total Collected','Total Coln']),
    Opening: dcFindCol_(headers, ['Opening Balance','Opening']),
    Due:     dcFindCol_(headers, ['Due Today','Due']),
    CollectedToday: dcFindCol_(headers, ['Collected Today','Collected']),
    Closing: dcFindCol_(headers, ['Closing Balance','Closing']),
    Done:    dcFindCol_(headers, ['Settlement Done']),
    At:      dcFindCol_(headers, ['Settlement At']),
    UpdatedAt: dcFindCol_(headers, ['Updated At']),
    Notes:   dcFindCol_(headers, ['Notes']),
    Raw:     dcFindCol_(headers, ['Raw Payload']),
    width:   headers.length
  };
}

// Normalize any date cell to 'yyyy-MM-dd' in IST
function dcNormDate_(val) {
  var tz = Session.getScriptTimeZone() || 'Asia/Kolkata';
  if (val instanceof Date) return Utilities.formatDate(val, tz, 'yyyy-MM-dd');
  var s = String(val || '');
  if (/^\d{4}-\d{2}-\d{2}$/.test(s)) return s;
  var d = new Date(s);
  if (!isNaN(d.getTime())) return Utilities.formatDate(d, tz, 'yyyy-MM-dd');
  return s;
}
// Derive cash/online from Raw Payload when columns are missing
function dcReadCashOnlineFromRaw_(rawCell) {
  try {
    const raw = JSON.parse(String(rawCell || '{}'));
    if (typeof raw.cash === 'number' || typeof raw.online === 'number') {
      return { cash: Number(raw.cash || 0) || 0, online: Number(raw.online || 0) || 0 };
    }
    const logs = Array.isArray(raw.logs) ? raw.logs : [];
    var c = 0, o = 0;
    for (var i = 0; i < logs.length; i++) {
      c += Number(logs[i] && logs[i].cash || 0) || 0;
      o += Number(logs[i] && logs[i].online || 0) || 0;
    }
    return { cash: c, online: o };
  } catch (_) { return { cash: 0, online: 0 }; }
}

function updateDailyCollection_(branch, staff, amount, type, opt) {
  const b = String(branch || '').trim();
  const s = String(staff || '').trim();
  const amt = dcToNum_(amount);

  const cashInc   = dcToNum_(opt && opt.cashCollected);
  const onlineInc = dcToNum_(opt && opt.onlineCollected);

  if (!b || !s || !(amt > 0)) {
    return { success:false, message:'missing branch/staff or amount<=0' };
  }

  const sh = dcGetSheet_();
  const headers = sh.getRange(1,1,1,sh.getLastColumn()).getValues()[0];
  const I = dcIdx_(headers);
  const dateStr = dcTodayStrIndia_();

  const last = sh.getLastRow();
  let hit = -1;

  if (last > 1) {
    const rows = sh.getRange(2,1,last-1,I.width).getValues();
    for (let i = rows.length - 1; i >= 0; i--) {
      const r = rows[i];
      const sameDate = dcNormDate_(r[I.Date]) === dateStr;
      const sameBranch = String(r[I.Branch] || '').trim().toLowerCase() === b.toLowerCase();
      const sameStaff = String(r[I.Staff] || '').trim().toLowerCase() === s.toLowerCase();
      const notDone = String(r[I.Done] || '').toLowerCase() !== 'true';
      if (sameDate && sameBranch && sameStaff && notDone) {
        hit = i + 2;
        break;
      }
    }
  }

  if (hit < 0) {
    const row = new Array(I.width).fill('');
    row[I.Date] = dateStr;
    row[I.Branch] = b;
    row[I.Staff] = s;

    row[I.Booking] = 0;
    row[I.JC]      = 0;
    row[I.Minor]   = 0;

    if (type === 'booking')         row[I.Booking] = amt;
    else if (type === 'jc')         row[I.JC]      = amt;
    else if (type === 'minorsales') row[I.Minor]   = amt;

    row[I.Total] = dcToNum_(row[I.Booking]) + dcToNum_(row[I.JC]) + dcToNum_(row[I.Minor]);

    if (I.Cash >= 0)   row[I.Cash]   = cashInc;
    if (I.Online >= 0) row[I.Online] = onlineInc;

    row[I.Done]  = false;
    row[I.At]    = '';
    row[I.Raw]   = JSON.stringify({ createdAt: dcTsIndia_(), type, amount: amt, cash: cashInc, online: onlineInc });

    sh.appendRow(row);
    hit = sh.getLastRow();
  } else {
    const cur = sh.getRange(hit,1,1,I.width).getValues()[0];

    if (type === 'booking')         cur[I.Booking] = dcToNum_(cur[I.Booking]) + amt;
    else if (type === 'jc')         cur[I.JC]      = dcToNum_(cur[I.JC]) + amt;
    else if (type === 'minorsales') cur[I.Minor]   = dcToNum_(cur[I.Minor]) + amt;

    cur[I.Total] = dcToNum_(cur[I.Booking]) + dcToNum_(cur[I.JC]) + dcToNum_(cur[I.Minor]);

    if (I.Cash >= 0)   cur[I.Cash]   = dcToNum_(cur[I.Cash])   + cashInc;
    if (I.Online >= 0) cur[I.Online] = dcToNum_(cur[I.Online]) + onlineInc;
    if (I.TotalCollected >= 0) cur[I.TotalCollected] = (I.Cash>=0?dcToNum_(cur[I.Cash]):0) + (I.Online>=0?dcToNum_(cur[I.Online]):0);

    let raw = {};
    try { raw = JSON.parse(String(cur[I.Raw] || '{}')); } catch (_) {}
    if (!Array.isArray(raw.logs)) raw.logs = [];
    raw.logs.push({ at: dcTsIndia_(), type, amount: amt, cash: cashInc, online: onlineInc });
    cur[I.Raw] = JSON.stringify(raw);

    sh.getRange(hit,1,1,I.width).setValues([cur]);
  }

  // NEW: Append to StaffLedger (non-breaking)
  try {
    staffLedgerAppendFromDailyUpdate_(b, s, amt, type, opt);
  } catch (_){ /* ignore ledger errors to avoid breaking existing flow */ }

  const out = sh.getRange(hit,1,1,I.width).getValues()[0];

  return {
    success:true,
    updatedRow: {
      date: out[I.Date],
      branch: out[I.Branch],
      staff: out[I.Staff],
      booking: dcToNum_(out[I.Booking]),
      jc: dcToNum_(out[I.JC]),
      minor: dcToNum_(out[I.Minor]),
      cashAmount: (I.Cash>=0 ? dcToNum_(out[I.Cash]) : 0),
      onlineAmount: (I.Online>=0 ? dcToNum_(out[I.Online]) : 0),
      total: (I.TotalCollected>=0 ? dcToNum_(out[I.TotalCollected]) : dcToNum_(out[I.Total])),
      settled: String(out[I.Done]).toLowerCase() === 'true',
      settledAt: out[I.At] || ''
    }
  };
}

function settleCollection_(branch, staff, dateOpt) {
  const b = String(branch || '').trim();
  const s = String(staff || '').trim();
  const dateStr = String(dateOpt || dcTodayStrIndia_());

  const sh = dcGetSheet_();
  const headers = sh.getRange(1,1,1,sh.getLastColumn()).getValues()[0];
  const I = dcIdx_(headers);
  const last = sh.getLastRow();
  if (last <= 1) return { success:false, message:'No data' };

  const rows = sh.getRange(2,1,last-1,I.width).getValues();
  let hit = -1;

  for (let i = rows.length - 1; i >= 0; i--) {
    const r = rows[i];
    const sameDate = dcNormDate_(r[I.Date]) === dateStr;
    const sameBranch = String(r[I.Branch] || '').trim().toLowerCase() === b.toLowerCase();
    const sameStaff = String(r[I.Staff] || '').trim().toLowerCase() === s.toLowerCase();
    const notDone = String(r[I.Done] || '').toLowerCase() !== 'true';
    if (sameDate && sameBranch && sameStaff && notDone) {
      hit = i + 2;
      break;
    }
  }

  if (hit < 0) return { success:false, message:'Not found or already settled' };

  const cur = sh.getRange(hit,1,1,I.width).getValues()[0];
  // Compute closing to block settlement with pending amounts
  const opening = I.Opening>=0 ? dcToNum_(cur[I.Opening]) : 0;
  const due     = I.Due>=0 ? dcToNum_(cur[I.Due]) : (dcToNum_(cur[I.Booking]) + dcToNum_(cur[I.JC]) + dcToNum_(cur[I.Minor]));
  const coll    = I.CollectedToday>=0 ? dcToNum_(cur[I.CollectedToday]) : 0;
  const closing = opening + due - coll;
  if (closing > 0.00001) {
    return { success:false, message:'Cannot settle. Pending amount exists: ' + closing };
  }

  cur[I.Done] = true;
  cur[I.At] = dcTsIndia_();
  sh.getRange(hit,1,1,I.width).setValues([cur]);

  return {
    success:true,
    settled:true,
    row: hit,
    date: cur[I.Date],
    staff: cur[I.Staff],
    branch: cur[I.Branch]
  };
}

function getStaffCollectionSummary_(branch, staff) {
  const bKey = String(branch || '').trim().toLowerCase();
  const sKey = String(staff || '').trim().toLowerCase();
  const today = dcTodayStrIndia_();

  const sh = dcGetSheet_();
  const headers = sh.getRange(1,1,1,sh.getLastColumn()).getValues()[0];
  const I = dcIdx_(headers);
  const last = sh.getLastRow();
  if (last <= 1) {
    return { success:true, data: {
      bookingAmountPending:0, jcAmountPending:0, minorSalesAmountPending:0,
      totalPending:0, cashAmountPending:0, onlineAmountPending:0, settlementDone:true
    }};
  }

  const rows = sh.getRange(2,1,last-1,I.width).getValues();
  var booking=0, jc=0, minor=0;
  var any = false;
  var latestIdx = -1; var latestTs = 0; var latestRow = null;

  for (var idx = 0; idx < rows.length; idx++) {
    const r = rows[idx];
    const done = String(r[I.Done] || '').toLowerCase() === 'true';
    if (done) continue;

    const sameDate  = dcNormDate_(r[I.Date]) === today;
    const sameBranch= String(r[I.Branch] || '').trim().toLowerCase() === bKey;
    const sameStaff = String(r[I.Staff]  || '').trim().toLowerCase() === sKey;
    if (!(sameDate && sameBranch && sameStaff)) continue;

    any = true;
    booking += dcToNum_(r[I.Booking]);
    jc      += dcToNum_(r[I.JC]);
    minor   += dcToNum_(r[I.Minor]);

    // track latest row by Updated At or fallback to last row order
    var uts = 0;
    if (I.UpdatedAt >= 0) {
      const u = rows[idx][I.UpdatedAt];
      if (u instanceof Date) uts = u.getTime(); else if (u) { var d = new Date(String(u)); if (!isNaN(d.getTime())) uts = d.getTime(); }
    }
    if (uts >= latestTs) { latestTs = uts; latestIdx = idx; latestRow = rows[idx]; }
    if (latestTs === 0) { latestIdx = idx; latestRow = rows[idx]; }
  }

  var collected = 0, cash = 0, online = 0, closingPending = 0;
  if (latestRow) {
    const tot = (I.TotalCollected>=0 ? dcToNum_(latestRow[I.TotalCollected]) : 0) ||
                (I.Total>=0 ? dcToNum_(latestRow[I.Total]) : 0);
    const cashCol = (I.Cash>=0 ? dcToNum_(latestRow[I.Cash]) : 0);
    const onlineCol = (I.Online>=0 ? dcToNum_(latestRow[I.Online]) : 0);
    collected = tot || (I.CollectedToday>=0 ? dcToNum_(latestRow[I.CollectedToday]) : (cashCol + onlineCol));
    cash = cashCol || collected; // if split not available, assume all cash for handover indicator
    online = onlineCol;
    const opening = (I.Opening>=0 ? dcToNum_(latestRow[I.Opening]) : 0);
    const dueSum  = booking + jc + minor;
    const close   = opening + dueSum - collected;
    closingPending = Math.max(0, close);
  }

  return { success:true, data: {
    bookingAmountPending: booking,
    jcAmountPending: jc,
    minorSalesAmountPending: minor,
    totalPending: collected,
    cashAmountPending: cash,
    onlineAmountPending: online,
    bookingAmount: booking, jcAmount: jc, minorSalesAmount: minor,
    total: collected, cashAmount: cash, onlineAmount: online,
    closingPending,
    settlementDone: !any
  }};
}

function collections_(opts) {
  const sh = dcGetSheet_();
  const headers = sh.getRange(1,1,1,sh.getLastColumn()).getValues()[0];
  const I = dcIdx_(headers);
  const last = sh.getLastRow();
  if (last <= 1) return { ok:true, data:[], total:0 };

  const rows = sh.getRange(2,1,last-1,I.width).getValues();
  const wantBranch = String(opts && opts.branch || '').trim().toLowerCase();
  const wantDate = String(opts && opts.date || '').trim();
  const page = Math.max(parseInt((opts && opts.page) || '1', 10) || 1, 1);
  const pageSize = Math.min(100, Math.max(0, parseInt((opts && opts.pageSize) || '10',10) || 10));

  function prevClosingFor(dateStr, branch, staff) {
    try {
      let best = '', prev = 0;
      for (let i=0;i<rows.length;i++) {
        const rr = rows[i];
        const d = dcNormDate_(rr[I.Date]);
        if (!d || d >= dateStr) continue;
        if (String(rr[I.Branch]||'').trim().toLowerCase() !== String(branch||'').trim().toLowerCase()) continue;
        if (String(rr[I.Staff]||'').trim().toLowerCase() !== String(staff||'').trim().toLowerCase()) continue;
        if (best === '' || d > best) { best = d; prev = (I.Closing>=0 ? dcToNum_(rr[I.Closing]) : 0); }
      }
      return prev;
    } catch(_) { return 0; }
  }

  const arr = rows.map((r, rowIx) => {
    // Cash/Online robust read
    let cash = 0, online = 0;
    if (I.Cash >= 0 && I.Online >= 0) {
      cash = dcToNum_(r[I.Cash]);
      online = dcToNum_(r[I.Online]);
    } else if (I.Raw >= 0) {
      const x = dcReadCashOnlineFromRaw_(r[I.Raw]);
      cash = x.cash; online = x.online;
    }

    // Base numbers
    const book = dcToNum_(r[I.Booking]);
    const jc   = dcToNum_(r[I.JC]);
    const minor= dcToNum_(r[I.Minor]);
    const derivedDue = book + jc + minor;

    const totalCollectedPref =
      (I.TotalCollected >= 0 ? dcToNum_(r[I.TotalCollected]) : 0) ||
      (I.Total >= 0 ? dcToNum_(r[I.Total]) : 0) ||
      (cash + online);

    // Opening: prefer sheet; fallback to previous closing
    const openingRaw = I.Opening >= 0 ? dcToNum_(r[I.Opening]) : 0;
    let opening = openingRaw;
    if (!opening) {
      opening = prevClosingFor(dcNormDate_(r[I.Date]), r[I.Branch], r[I.Staff]);
    }

    // Due: prefer sheet value when present and > 0; otherwise derive
    let dueToday = I.Due >= 0 ? dcToNum_(r[I.Due]) : 0;
    if (!dueToday) dueToday = derivedDue;

    // Collected: prefer explicit column when > 0; otherwise use totals
    let collToday = I.CollectedToday >= 0 ? dcToNum_(r[I.CollectedToday]) : 0;
    if (!collToday) collToday = totalCollectedPref;

    const closing = opening + dueToday - collToday;

    // Opportunistically write back computed Opening so the sheet stays correct and the UI
    // does not need historical lookbacks. Only write when sheet has 0/blank and we computed > 0.
    try {
      if (I.Opening >= 0 && openingRaw === 0 && opening > 0) {
        sh.getRange(2 + rowIx, 1 + I.Opening).setValue(opening);
      }
    } catch (_) { /* ignore write errors in read path */ }

    return {
      date: dcNormDate_(r[I.Date]),
      branch: r[I.Branch],
      staff: r[I.Staff],
      bookingAmount: book,
      jcAmount: jc,
      minorSalesAmount: minor,
      cashAmount: cash,
      onlineAmount: online,
      total: totalCollectedPref,
      openingBalance: opening,
      dueToday,
      collectedToday: collToday,
      closingBalance: closing,
      settlementDone: String(r[I.Done]).toLowerCase() === 'true',
      settlementAt: r[I.At] || '',
      updatedAt: I.UpdatedAt >= 0 ? (r[I.UpdatedAt] || '') : ''
    };
  }).filter(x => {
    if (wantBranch && String(x.branch || '').trim().toLowerCase() !== wantBranch) return false;
    if (wantDate && String(x.date || '') !== wantDate) return false;
    return true;
  });

  arr.sort((a,b) =>
    String(b.date).localeCompare(String(a.date)) ||
    String(b.settlementAt || '').localeCompare(String(a.settlementAt || ''))
  );

  const total = arr.length;
  const start = (page - 1) * pageSize;
  const data = pageSize > 0 ? arr.slice(start, start + pageSize) : arr;

  return { ok:true, data, total };
}

// Update Opening/Due/Collected/Closing on the same DailyCollections row
function updateCollectionDC_(req) {
  const date = String(req.date || '').trim();
  const branch = String(req.branch || '').trim();
  const staff = String(req.staff || '').trim();
  const collectedToday = dcToNum_(req.collectedToday);
  if (!date || !branch || !staff) return { success:false, message:'date/branch/staff required' };

  const sh = dcGetSheet_();
  const headers = sh.getRange(1,1,1,sh.getLastColumn()).getValues()[0];
  const I = dcIdx_(headers);
  const last = sh.getLastRow();

  let hit = -1;
  let rows = [];
  if (last > 1) {
    rows = sh.getRange(2,1,last-1,I.width).getValues();
    for (let i = rows.length - 1; i >= 0; i--) {
      const r = rows[i];
      if (dcNormDate_(r[I.Date]) === date && String(r[I.Branch]||'').trim().toLowerCase() === branch.toLowerCase() && String(r[I.Staff]||'').trim().toLowerCase() === staff.toLowerCase()) {
        hit = i + 2; break;
      }
    }
  }

  if (hit < 0) { // create new
    const row = new Array(I.width).fill('');
    row[I.Date] = date; row[I.Branch] = branch; row[I.Staff] = staff;
    if (I.Opening >= 0) row[I.Opening] = 0;
    if (I.Due >= 0) row[I.Due] = 0;
    if (I.CollectedToday >= 0) row[I.CollectedToday] = collectedToday;
    if (I.Closing >= 0) row[I.Closing] = 0;
    if (I.UpdatedAt >= 0) row[I.UpdatedAt] = dcTsIndia_();
    sh.appendRow(row);
    hit = sh.getLastRow();
    rows = sh.getRange(2,1,hit-1,I.width).getValues();
  }

  const cur = sh.getRange(hit,1,1,I.width).getValues()[0];

  const prevClosing = (function(){
    let prev = 0, best = '';
    for (let i=0;i<rows.length;i++){
      const r = rows[i];
      if (String(r[I.Branch]||'').trim().toLowerCase() !== branch.toLowerCase()) continue;
      if (String(r[I.Staff]||'').trim().toLowerCase() !== staff.toLowerCase()) continue;
      const rd = dcNormDate_(r[I.Date]);
      if (!rd || rd >= date) continue;
      if (best === '' || rd > best) { best = rd; prev = (I.Closing>=0 ? dcToNum_(r[I.Closing]) : 0); }
    }
    return prev;
  })();

  const booking = I.Booking>=0 ? dcToNum_(cur[I.Booking]) : 0;
  const jc = I.JC>=0 ? dcToNum_(cur[I.JC]) : 0;
  const minor = I.Minor>=0 ? dcToNum_(cur[I.Minor]) : 0;
  const dueToday = booking + jc + minor;
  const opening = (I.Opening>=0 ? dcToNum_(cur[I.Opening]) : 0) || prevClosing;
  const closing = opening + dueToday - collectedToday;

  if (I.Opening>=0) cur[I.Opening] = opening;
  if (I.Due>=0) cur[I.Due] = dueToday;
  if (I.CollectedToday>=0) cur[I.CollectedToday] = collectedToday;
  if (I.Closing>=0) cur[I.Closing] = closing;
  if (I.TotalCollected>=0) cur[I.TotalCollected] = (I.Cash>=0?dcToNum_(cur[I.Cash]):0) + (I.Online>=0?dcToNum_(cur[I.Online]):0);
  if (I.UpdatedAt>=0) cur[I.UpdatedAt] = dcTsIndia_();

  sh.getRange(hit,1,1,I.width).setValues([cur]);
  return { success:true, row: hit, date, branch, staff, openingBalance: opening, dueToday, collectedToday, closingBalance: closing };
}

/* ============================
   StaffLedger (NEW HELPERS + ENDPOINT LOGIC)
   Sheet: StaffLedger in the same master spreadsheet as DailyCollections
============================ */

const STAFF_LEDGER_SHEET = 'StaffLedger';
const STAFF_LEDGER_HEADERS = [
  'DateTime ISO','Date','Branch','Staff',
  'Source Type','Source ID',
  'Customer Name','Customer Mobile',
  'Payment Mode','Cash Amount','Online Amount','UTR / Ref No',
  'Collected Total','Settled Cash','Settled Online','Settled Total',
  'Settled Flag','Settled At','Settled By','Raw Payload'
];

const STAFF_PREV_DUE_SHEET = 'StaffPrevDue';
const STAFF_PREV_DUE_HEADERS = [
  'Branch','Staff','Amount','Note','Updated By','Updated At','Created At'
];

function slNowIsoIndia_(){
  const tz = Session.getScriptTimeZone() || 'Asia/Kolkata';
  return Utilities.formatDate(new Date(), tz, "yyyy-MM-dd'T'HH:mm:ss.SSSXXX");
}
function slDateIndia_(d){
  const tz = Session.getScriptTimeZone() || 'Asia/Kolkata';
  return Utilities.formatDate(d || new Date(), tz, 'yyyy-MM-dd');
}

function staffLedgerGetSheet_(){
  const masterId = typeof DC_MASTER_SPREADSHEET_ID === 'string' ? DC_MASTER_SPREADSHEET_ID : '';
  const ss = masterId ? SpreadsheetApp.openById(masterId) : (SHEET_ID ? SpreadsheetApp.openById(SHEET_ID) : SpreadsheetApp.getActiveSpreadsheet());
  let sh = ss.getSheetByName(STAFF_LEDGER_SHEET);
  if (!sh) sh = ss.insertSheet(STAFF_LEDGER_SHEET);
  const width = Math.max(sh.getLastColumn(), STAFF_LEDGER_HEADERS.length);
  const first = width ? sh.getRange(1,1,1,width).getValues()[0] : [];
  const hasAny = first.some(v => String(v||'').trim().length);
  if (!hasAny) sh.getRange(1,1,1,STAFF_LEDGER_HEADERS.length).setValues([STAFF_LEDGER_HEADERS]);
  return sh;
}

function staffLedgerIdx_(headers){
  const H = headers.map(h => String(h||'').trim().toLowerCase());
  const find = (name) => H.indexOf(String(name||'').trim().toLowerCase());
  return {
    DateTimeISO: find('datetime iso'),
    Date: find('date'),
    Branch: find('branch'),
    Staff: find('staff'),
    SrcType: find('source type'),
    SrcId: find('source id'),
    CustName: find('customer name'),
    CustMobile: find('customer mobile'),
    PayMode: find('payment mode'),
    Cash: find('cash amount'),
    Online: find('online amount'),
    UTR: find('utr / ref no'),
    Total: find('collected total'),
    SCash: find('settled cash'),
    SOnline: find('settled online'),
    STotal: find('settled total'),
    SFlag: find('settled flag'),
    SAt: find('settled at'),
    SBy: find('settled by'),
    Raw: find('raw payload'),
    width: headers.length
  };
}

function appendStaffLedgerTransaction_(rowObj){
  const sh = staffLedgerGetSheet_();
  const headers = sh.getRange(1,1,1,Math.max(sh.getLastColumn(), STAFF_LEDGER_HEADERS.length)).getValues()[0];
  const I = staffLedgerIdx_(headers);
  const row = new Array(I.width).fill('');
  const put = (i,v)=>{ if (i>=0) row[i] = (v==null?'':v); };
  put(I.DateTimeISO, rowObj.dateTimeIso || slNowIsoIndia_());
  put(I.Date, rowObj.date || slDateIndia_(new Date()));
  put(I.Branch, rowObj.branch || '');
  put(I.Staff, rowObj.staff || '');
  put(I.SrcType, rowObj.sourceType || '');
  put(I.SrcId, rowObj.sourceId || '');
  put(I.CustName, rowObj.customerName || '');
  put(I.CustMobile, rowObj.customerMobile || '');
  put(I.PayMode, rowObj.paymentMode || '');
  put(I.Cash, Number(rowObj.cashAmount||0)||0);
  put(I.Online, Number(rowObj.onlineAmount||0)||0);
  put(I.UTR, rowObj.utr || '');
  const cash = Number(rowObj.cashAmount||0)||0;
  const online = Number(rowObj.onlineAmount||0)||0;
  put(I.Total, cash + online);
  put(I.SCash, 0);
  put(I.SOnline, 0);
  put(I.STotal, 0);
  put(I.SFlag, false);
  put(I.SAt, '');
  put(I.SBy, '');
  try { put(I.Raw, JSON.stringify(rowObj.rawPayload || {})); } catch(_){ put(I.Raw, ''); }
  sh.appendRow(row);
  return { row: sh.getLastRow() };
}

function staffLedgerAppendFromDailyUpdate_(branch, staff, amount, type, opt){
  try{
    const b = String(branch||'').trim();
    const s = String(staff||'').trim();
    const amt = dcToNum_(amount);
    if (!b || !s || !(amt>0)) return { skipped:true };
    const ctx = (opt && opt.staffLedgerContext) || {};
    let cash = dcToNum_(opt && opt.cashCollected);
    let online = dcToNum_(opt && opt.onlineCollected);

    // Try derive split from ctx.payments if missing
    if (!(cash>0) && !(online>0) && Array.isArray(ctx.payments)){
      try {
        cash = ctx.payments.filter(p=>String(p.mode||'').toLowerCase()==='cash').reduce((a,p)=>a+(Number(p.amount)||0),0);
        online = ctx.payments.filter(p=>String(p.mode||'').toLowerCase()==='online').reduce((a,p)=>a+(Number(p.amount)||0),0);
      } catch(_) {}
    }
    // Fallback from paymentMode
    if (!(cash>0) && !(online>0)){
      const pm = String(ctx.paymentMode || '').toLowerCase();
      if (pm === 'cash') cash = amt; else if (pm) online = amt; else cash = amt;
    }
    const pmode = (cash>0 && online>0) ? 'mixed' : (cash>0 ? 'cash' : (online>0 ? 'online' : ''));
    // UTR from ctx or payments
    let utr = String(ctx.utr||'').trim();
    if (!utr && Array.isArray(ctx.payments)){
      try {
        const p = ctx.payments.find(p=>String(p.mode||'').toLowerCase()==='online');
        utr = String(p && (p.utr || p.ref || p.reference || p.txnId || p.txn || p.upiRef || '')).trim();
      } catch(_) {}
    }
    const sourceId = String(ctx.sourceId||ctx.jcNo||ctx.bookingId||ctx.orderId||'').trim();
    const mobile10 = String(ctx.customerMobile || ctx.custMobile || '').replace(/\D/g,'').slice(-10);
    let custName = String(ctx.customerName || ctx.custName || '').trim();
    // Fallback: if name missing, try fetch from existing JobCard row by JC or Mobile
    if (!custName && (mobile10 || sourceId)){
      try {
        const found = findExistingRowFull_(mobile10, sourceId);
        if (found){
          const fv = (found.payload && found.payload.formValues) ? found.payload.formValues : {};
          const fromSheet = (found.rowValues && found.ix && found.ix.idxName>=0) ? String(found.rowValues[found.ix.idxName]||'') : '';
          custName = String(fv.custName || fv.customerName || fromSheet || '').trim();
        }
      } catch(_){ /* ignore */ }
    }

    const obj = {
      branch: b,
      staff: s,
      sourceType: String(type||'').toLowerCase(),
      sourceId: sourceId,
      customerName: custName,
      customerMobile: mobile10,
      paymentMode: pmode,
      cashAmount: cash,
      onlineAmount: online,
      utr: utr,
      rawPayload: { from: 'updateDailyCollection_', ctx }
    };
    return appendStaffLedgerTransaction_(obj);
  }catch(err){ return { error: String(err) }; }
}

function staffLedgerRowKey_(row, I){
  const norm = (v) => String(v || '').trim().toLowerCase();
  const cell = (idx) => (idx >= 0 ? row[idx] : '');
  return [
    norm(cell(I.Branch)),
    norm(cell(I.Staff)),
    norm(cell(I.SrcType)),
    norm(cell(I.SrcId)),
    norm(cell(I.CustMobile)),
    norm(cell(I.PayMode)),
    norm(cell(I.Cash)),
    norm(cell(I.Online)),
    norm(cell(I.UTR))
  ].join('|');
}

function staffLedgerRowTs_(row, I){
  const raw = (I.DateTimeISO >= 0 ? row[I.DateTimeISO] : (I.Date >= 0 ? row[I.Date] : ''));
  const t = raw instanceof Date ? raw.getTime() : (new Date(String(raw))).getTime();
  return isFinite(t) ? t : 0;
}

function staffLedgerSummary_(branch, staff){
  const b = String(branch||'').trim().toLowerCase();
  const s = String(staff||'').trim().toLowerCase();
  const sh = staffLedgerGetSheet_();
  const headers = sh.getRange(1,1,1,Math.max(sh.getLastColumn(), STAFF_LEDGER_HEADERS.length)).getValues()[0];
  const I = staffLedgerIdx_(headers);
  const last = sh.getLastRow();
  if (last <= 1) return { success:true, data: { branch:branch, staff:staff, cashPending:0, onlinePending:0, totalPending:0 } };
  const rows = sh.getRange(2,1,last-1,I.width).getValues();
  const groups = {};
  let lastSettledAt = '';
  for (let i=0;i<rows.length;i++){
    const r = rows[i];
    if (String(r[I.Branch]||'').trim().toLowerCase() !== b) continue;
    if (String(r[I.Staff]||'').trim().toLowerCase() !== s) continue;
    const cashAmt = Number(r[I.Cash]||0)||0;
    const onAmt = Number(r[I.Online]||0)||0;
    const sc = Number(r[I.SCash]||0)||0;
    const so = Number(r[I.SOnline]||0)||0;
    const key = staffLedgerRowKey_(r, I);
    const g = groups[key];
    if (!g) {
      groups[key] = { cashAmt, onAmt, scMax: sc, soMax: so };
    } else {
      g.scMax = Math.max(g.scMax, sc);
      g.soMax = Math.max(g.soMax, so);
    }
    const sat = r[I.SAt];
    if (sat) { const t = (sat instanceof Date) ? sat.getTime() : (new Date(String(sat))).getTime(); if (isFinite(t)) lastSettledAt = String(sat); }
  }
  let c=0,o=0;
  const keys = Object.keys(groups);
  for (let i=0;i<keys.length;i++){
    const g = groups[keys[i]];
    const cp = Math.max(0, g.cashAmt - g.scMax);
    const op = Math.max(0, g.onAmt - g.soMax);
    if (cp>0 || op>0){ c += cp; o += op; }
  }
  const prevDueRow = staffPrevDueFetch_(branch, staff);
  const prevDueAmt = dcToNum_(prevDueRow && prevDueRow.amount);
  return { success:true, data: {
    branch,
    staff,
    cashPending:c,
    onlinePending:o,
    totalPending:(c+o),
    lastSettledAt,
    prevDueAssigned: prevDueAmt,
    prevDueNote: prevDueRow && prevDueRow.note ? String(prevDueRow.note) : '',
    prevDueUpdatedAt: prevDueRow && prevDueRow.updatedAt ? String(prevDueRow.updatedAt) : '',
    prevDueUpdatedBy: prevDueRow && prevDueRow.updatedBy ? String(prevDueRow.updatedBy) : ''
  } };
}

function staffLedgerTransactions_(branch, staff, mode){
  const m = String(mode||'all').toLowerCase();
  const bKey = String(branch||'').trim().toLowerCase();
  const sKey = String(staff||'').trim().toLowerCase();
  const sh = staffLedgerGetSheet_();
  const headers = sh.getRange(1,1,1,Math.max(sh.getLastColumn(), STAFF_LEDGER_HEADERS.length)).getValues()[0];
  const I = staffLedgerIdx_(headers);
  const last = sh.getLastRow();
  const out = [];
  if (last > 1){
    const rows = sh.getRange(2,1,last-1,I.width).getValues();
    const groups = {};
    for (let i=0;i<rows.length;i++){
      const r = rows[i];
      if (String(r[I.Branch]||'').trim().toLowerCase() !== bKey) continue;
      if (String(r[I.Staff]||'').trim().toLowerCase() !== sKey) continue;
      const cashAmt = Number(r[I.Cash]||0)||0;
      const onAmt = Number(r[I.Online]||0)||0;
      const sc = Number(r[I.SCash]||0)||0;
      const so = Number(r[I.SOnline]||0)||0;
      const key = staffLedgerRowKey_(r, I);
      const ts = staffLedgerRowTs_(r, I);
      const g = groups[key];
      if (!g) {
        groups[key] = { row: r, ts, cashAmt, onAmt, scMax: sc, soMax: so };
      } else {
        g.scMax = Math.max(g.scMax, sc);
        g.soMax = Math.max(g.soMax, so);
        if (ts >= g.ts) { g.row = r; g.ts = ts; }
      }
    }
    const keys = Object.keys(groups);
    for (let i=0;i<keys.length;i++){
      const g = groups[keys[i]];
      const cp = Math.max(0, g.cashAmt - g.scMax);
      const op = Math.max(0, g.onAmt - g.soMax);
      const totalPend = cp + op;
      if (!(totalPend>0)) continue;
      if (m==='cash' && !(cp>0)) continue;
      if (m==='online' && !(op>0)) continue;
      const r = g.row;
      out.push({
        dateTimeIso: r[I.DateTimeISO],
        date: r[I.Date],
        sourceType: r[I.SrcType],
        sourceId: r[I.SrcId],
        customerName: r[I.CustName],
        customerMobile: r[I.CustMobile],
        paymentMode: r[I.PayMode],
        cashPending: cp,
        onlinePending: op,
        utr: r[I.UTR]
      });
    }
  }
  return { success:true, rows: out };
}

function ownerLedgerList_(opts){
  const sh = staffLedgerGetSheet_();
  const headers = sh.getRange(1,1,1,Math.max(sh.getLastColumn(), STAFF_LEDGER_HEADERS.length)).getValues()[0];
  const I = staffLedgerIdx_(headers);
  const last = sh.getLastRow();
  const wantBranch = String(opts && opts.branch || '').trim().toLowerCase();
  const wantStaff  = String(opts && opts.staff  || '').trim().toLowerCase();
  const status     = String(opts && opts.status || 'unsettled').toLowerCase();
  const fromDate   = String(opts && opts.fromDate || '');
  const toDate     = String(opts && opts.toDate || '');
  const rows = (last>1) ? sh.getRange(2,1,last-1,I.width).getValues() : [];
  const within = (d) => {
    const dd = slDateIndia_(d);
    if (fromDate && dd < fromDate) return false;
    if (toDate && dd > toDate) return false;
    return true;
  };
  const out = [];
  for (let i=0;i<rows.length;i++){
    const r = rows[i];
    const b = String(r[I.Branch]||'').trim();
    const s = String(r[I.Staff]||'').trim();
    if (wantBranch && b.toLowerCase() !== wantBranch) continue;
    if (wantStaff && s.toLowerCase() !== wantStaff) continue;
    const d = r[I.Date] || slDateIndia_(r[I.DateTimeISO]||new Date());
    if (!within(d)) continue;
    const cashAmt = Number(r[I.Cash]||0)||0;
    const onAmt = Number(r[I.Online]||0)||0;
    const sc = Number(r[I.SCash]||0)||0;
    const so = Number(r[I.SOnline]||0)||0;
    const cp = Math.max(0, cashAmt - sc);
    const op = Math.max(0, onAmt - so);
    const settledFlag = String(r[I.SFlag]||'').toLowerCase()==='true';
    const unsettled = (cp + op) > 0;
    if (status==='unsettled' && !unsettled) continue;
    if (status==='settled' && !settledFlag) continue;
    out.push({
      id: i+2, // actual sheet row index
      dateTimeIso: r[I.DateTimeISO],
      date: d,
      branch: b,
      staff: s,
      sourceType: r[I.SrcType],
      sourceId: r[I.SrcId],
      customerName: r[I.CustName],
      customerMobile: r[I.CustMobile],
      paymentMode: r[I.PayMode],
      cashAmount: cashAmt,
      onlineAmount: onAmt,
      cashPending: cp,
      onlinePending: op,
      utr: r[I.UTR],
      settledFlag: settledFlag,
      settledAt: r[I.SAt] || '',
      settledBy: r[I.SBy] || ''
    });
  }
  return { success:true, rows: out };
}

function staffLedgerSettleRows_(ids, mode, settledBy, scope){
  const sh = staffLedgerGetSheet_();
  const headers = sh.getRange(1,1,1,Math.max(sh.getLastColumn(), STAFF_LEDGER_HEADERS.length)).getValues()[0];
  const I = staffLedgerIdx_(headers);
  const nowIso = slNowIsoIndia_();
  let updated = 0;
  const idsArr = Array.isArray(ids) ? ids.slice() : [];
  idsArr.sort((a,b)=>a-b);
  for (let k=0;k<idsArr.length;k++){
    const rowIx = idsArr[k];
    if (!Number.isFinite(rowIx) || rowIx < 2) continue;
    const r = sh.getRange(rowIx,1,1,I.width).getValues()[0];
    // Optional scope filter
    if (scope && scope.branch && String(r[I.Branch]||'').trim().toLowerCase() !== String(scope.branch).trim().toLowerCase()) continue;
    if (scope && scope.staff && String(r[I.Staff]||'').trim().toLowerCase() !== String(scope.staff).trim().toLowerCase()) continue;
    const cashAmt = Number(r[I.Cash]||0)||0;
    const onAmt   = Number(r[I.Online]||0)||0;
    let sCash = Number(r[I.SCash]||0)||0;
    let sOn   = Number(r[I.SOnline]||0)||0;
    const m = String(mode||'both').toLowerCase();
    if (m==='cash' || m==='both') sCash = cashAmt;
    if (m==='online' || m==='both') sOn = onAmt;
    const sTot = sCash + sOn;
    const tot = cashAmt + onAmt;
    const flag = (sTot >= tot);
    r[I.SCash] = sCash;
    r[I.SOnline] = sOn;
    r[I.STotal] = sTot;
    r[I.SFlag] = flag;
    if (flag) {
      r[I.SAt] = nowIso;
      r[I.SBy] = String(settledBy||'OWNER');
    }
    sh.getRange(rowIx,1,1,I.width).setValues([r]);
    updated++;
  }
  return { updatedCount: updated };
}

/* ============================
   Staff Previous Due assignments (owner managed)
============================ */
function staffPrevDueGetSheet_(){
  const masterId = typeof DC_MASTER_SPREADSHEET_ID === 'string' ? DC_MASTER_SPREADSHEET_ID : '';
  const ss = masterId ? SpreadsheetApp.openById(masterId) : (SHEET_ID ? SpreadsheetApp.openById(SHEET_ID) : SpreadsheetApp.getActiveSpreadsheet());
  let sh = ss.getSheetByName(STAFF_PREV_DUE_SHEET);
  if (!sh) sh = ss.insertSheet(STAFF_PREV_DUE_SHEET);
  const width = Math.max(sh.getLastColumn(), STAFF_PREV_DUE_HEADERS.length);
  const first = width ? sh.getRange(1,1,1,width).getValues()[0] : [];
  const hasAny = first.some(v => String(v||'').trim().length);
  if (!hasAny) sh.getRange(1,1,1,STAFF_PREV_DUE_HEADERS.length).setValues([STAFF_PREV_DUE_HEADERS]);
  return sh;
}

function staffPrevDueIdx_(headers){
  const norm = (s) => String(s||'').trim().toLowerCase();
  const H = headers.map(norm);
  const find = (name) => H.indexOf(norm(name));
  return {
    Branch: find('branch'),
    Staff: find('staff'),
    Amount: find('amount'),
    Note: find('note'),
    UpdatedBy: find('updated by'),
    UpdatedAt: find('updated at'),
    CreatedAt: find('created at'),
    width: headers.length
  };
}

function ownerPrevDueList_(opts){
  const sh = staffPrevDueGetSheet_();
  const headers = sh.getRange(1,1,1,Math.max(sh.getLastColumn(), STAFF_PREV_DUE_HEADERS.length)).getValues()[0];
  const I = staffPrevDueIdx_(headers);
  const last = sh.getLastRow();
  const wantBranch = String(opts && opts.branch || '').trim().toLowerCase();
  const wantStaff = String(opts && opts.staff || '').trim().toLowerCase();
  const rows = (last>1) ? sh.getRange(2,1,last-1,I.width).getValues() : [];
  const list = [];
  rows.forEach((r, idx) => {
    const branch = String(r[I.Branch]||'').trim();
    const staff = String(r[I.Staff]||'').trim();
    if (wantBranch && branch.toLowerCase() !== wantBranch) return;
    if (wantStaff && staff.toLowerCase() !== wantStaff) return;
    list.push({
      id: idx + 2,
      branch,
      staff,
      amount: dcToNum_(r[I.Amount]),
      note: r[I.Note] || '',
      updatedBy: r[I.UpdatedBy] || '',
      updatedAt: r[I.UpdatedAt] || '',
      createdAt: r[I.CreatedAt] || ''
    });
  });
  list.sort((a,b) => String(b.updatedAt||'').localeCompare(String(a.updatedAt||'')));
  return { success:true, rows: list };
}

function ownerPrevDueSet_(branch, staff, amount, note, updatedBy){
  const b = String(branch||'').trim();
  const s = String(staff||'').trim();
  if (!b || !s) return { success:false, message:'branch and staff required' };
  const amountProvided = !(amount == null || (typeof amount === 'string' && String(amount).trim() === ''));
  if (!amountProvided) return { success:false, message:'amount is required' };
  const amt = Math.max(0, dcToNum_(amount));
  const sh = staffPrevDueGetSheet_();
  const headers = sh.getRange(1,1,1,Math.max(sh.getLastColumn(), STAFF_PREV_DUE_HEADERS.length)).getValues()[0];
  const I = staffPrevDueIdx_(headers);
  const last = sh.getLastRow();
  const wantBranch = b.toLowerCase();
  const wantStaff = s.toLowerCase();
  let hit = -1;
  if (last > 1){
    const rows = sh.getRange(2,1,last-1,I.width).getValues();
    for (let i=rows.length-1;i>=0;i--){
      const r = rows[i];
      if (String(r[I.Branch]||'').trim().toLowerCase() !== wantBranch) continue;
      if (String(r[I.Staff]||'').trim().toLowerCase() !== wantStaff) continue;
      hit = i + 2;
      break;
    }
  }
  const nowIso = dcTsIndia_();
  if (hit > 0){
    const row = sh.getRange(hit,1,1,I.width).getValues()[0];
    if (I.Branch>=0) row[I.Branch] = b;
    if (I.Staff>=0) row[I.Staff] = s;
    if (I.Amount>=0) row[I.Amount] = amt;
    if (I.Note>=0) row[I.Note] = note || '';
    if (I.UpdatedBy>=0) row[I.UpdatedBy] = updatedBy || '';
    if (I.UpdatedAt>=0) row[I.UpdatedAt] = nowIso;
    sh.getRange(hit,1,1,I.width).setValues([row]);
    return { success:true, updated:true, row: hit, branch:b, staff:s, amount: amt };
  }
  const row = new Array(I.width).fill('');
  if (I.Branch>=0) row[I.Branch] = b;
  if (I.Staff>=0) row[I.Staff] = s;
  if (I.Amount>=0) row[I.Amount] = amt;
  if (I.Note>=0) row[I.Note] = note || '';
  if (I.UpdatedBy>=0) row[I.UpdatedBy] = updatedBy || '';
  if (I.UpdatedAt>=0) row[I.UpdatedAt] = nowIso;
  if (I.CreatedAt>=0) row[I.CreatedAt] = nowIso;
  sh.appendRow(row);
  return { success:true, created:true, row: sh.getLastRow(), branch:b, staff:s, amount: amt };
}

function staffPrevDueFetch_(branch, staff){
  const b = String(branch||'').trim().toLowerCase();
  const s = String(staff||'').trim().toLowerCase();
  if (!b || !s) return { branch: branch||'', staff: staff||'', amount:0 };
  const sh = staffPrevDueGetSheet_();
  const headers = sh.getRange(1,1,1,Math.max(sh.getLastColumn(), STAFF_PREV_DUE_HEADERS.length)).getValues()[0];
  const I = staffPrevDueIdx_(headers);
  const last = sh.getLastRow();
  if (last <= 1) return { branch: branch||'', staff: staff||'', amount:0 };
  const rows = sh.getRange(2,1,last-1,I.width).getValues();
  for (let i = rows.length - 1; i >= 0; i--) {
    const r = rows[i];
    if (String(r[I.Branch]||'').trim().toLowerCase() !== b) continue;
    if (String(r[I.Staff]||'').trim().toLowerCase() !== s) continue;
    return {
      branch: r[I.Branch] || '',
      staff: r[I.Staff] || '',
      amount: dcToNum_(r[I.Amount]),
      note: r[I.Note] || '',
      updatedBy: r[I.UpdatedBy] || '',
      updatedAt: r[I.UpdatedAt] || '',
      createdAt: r[I.CreatedAt] || '',
      row: i + 2
    };
  }
  return { branch: branch||'', staff: staff||'', amount:0 };
}
