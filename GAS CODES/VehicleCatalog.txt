/**
 * Vehicle Catalog Web App (Google Apps Script)
 * Supports list / upsert / delete for Company, Model, Variant, OnRoadPrice, plus audit (UpdatedAt/UpdatedBy).
 *
 * Deploy:
 *  - File > Project properties > copy Script ID for reference.
 *  - Deploy > New deployment > Select type "Web app".
 *  - Execute as: Me (the owner)
 *  - Who has access: Anyone with the link
 *  - After deploy, copy the Web App URL and set it in your client env as VITE_VEHICLE_CATALOG_GAS_URL.
 *
 * Expected sheet layout (first row headers):
 *  Company | Model | Variant | OnRoadPrice | Key | UpdatedAt | UpdatedBy
 */

// Target sheet: https://docs.google.com/spreadsheets/d/1XSwT6GQiXUsH_zH8VEymsrCfHb1QW_FbdKwMSqnE4_U/edit?gid=0#gid=0
const SPREADSHEET_ID = '1XSwT6GQiXUsH_zH8VEymsrCfHb1QW_FbdKwMSqnE4_U'; // Sheet ID
const SHEET_NAME = 'Catalog';

function getSheet_() {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheet = ss.getSheetByName(SHEET_NAME) || ss.insertSheet(SHEET_NAME);
  const headers = ['Company', 'Model', 'Variant', 'OnRoadPrice', 'Key', 'UpdatedAt', 'UpdatedBy'];
  const firstRow = sheet.getRange(1, 1, 1, headers.length).getValues()[0];
  const missing = headers.some((h, i) => String(firstRow[i] || '') !== h);
  if (missing) sheet.getRange(1, 1, 1, headers.length).setValues([headers]);
  return sheet;
}

function buildKey_(obj) {
  const toKey = (s) => String(s || '').trim().toUpperCase();
  return [toKey(obj.Company), toKey(obj.Model), toKey(obj.Variant)].join('|');
}

function readRows_() {
  const sheet = getSheet_();
  const values = sheet.getDataRange().getValues();
  if (values.length <= 1) return [];
  const headers = values[0];
  const rows = [];
  for (let i = 1; i < values.length; i++) {
    const row = values[i];
    const obj = {};
    headers.forEach((h, idx) => { obj[h] = row[idx]; });
    obj._row = i + 1; // 1-based row index in Sheet
    rows.push(obj);
  }
  return rows;
}

function writeRow_(sheet, rowIndex, obj) {
  const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  const row = headers.map((h) => obj[h] ?? '');
  sheet.getRange(rowIndex, 1, 1, headers.length).setValues([row]);
}

function doGet(e) {
  const action = (e && e.parameter && e.parameter.action) ? String(e.parameter.action).toLowerCase() : 'list';
  if (action === 'list') {
    const rows = readRows_();
    return ContentService.createTextOutput(JSON.stringify({ ok: true, rows, count: rows.length })).setMimeType(ContentService.MimeType.JSON);
  }
  return ContentService.createTextOutput(JSON.stringify({ ok: true, message: 'Vehicle Catalog API' })).setMimeType(ContentService.MimeType.JSON);
}

function doPost(e) {
  const payload = parseBody_(e);
  const action = String(payload.action || 'upsert').toLowerCase();
  try {
    if (action === 'delete') {
      return handleDelete_(payload);
    }
    return handleUpsert_(payload);
  } catch (err) {
    return ContentService.createTextOutput(JSON.stringify({ ok: false, message: err.message || String(err) }))
      .setMimeType(ContentService.MimeType.JSON);
  }
}

function handleUpsert_(payload) {
  const sheet = getSheet_();
  const required = ['company', 'model', 'variant'];
  required.forEach((k) => {
    if (!payload[k]) throw new Error('Missing ' + k);
  });
  const rec = {
    Company: String(payload.company).trim(),
    Model: String(payload.model).trim(),
    Variant: String(payload.variant).trim(),
    OnRoadPrice: Number(payload.onRoadPrice || 0) || 0,
    UpdatedBy: payload.updatedBy ? String(payload.updatedBy).trim() : '',
  };
  rec.Key = buildKey_(rec);
  rec.UpdatedAt = new Date();

  const rows = readRows_();
  const lastRow = sheet.getLastRow();
  const lookupKeyRaw = payload.key || payload.previousKey || payload.originalKey || '';
  const targetKey = lookupKeyRaw ? String(lookupKeyRaw).toUpperCase() : rec.Key;
  const rowIdRaw = payload.id || payload.rowId || payload.row || payload._row;
  const rowId = rowIdRaw ? Number(rowIdRaw) : NaN;
  let rowNumber = null;

  if (!isNaN(rowId) && rowId >= 2 && rowId <= lastRow) {
    const rowIdValue = Math.floor(rowId);
    if (!lookupKeyRaw) {
      rowNumber = rowIdValue;
    } else {
      const rowById = rows.find((r) => r._row === rowIdValue);
      if (rowById && buildKey_(rowById) === targetKey) rowNumber = rowIdValue;
    }
  }

  if (!rowNumber) {
    const idx = rows.findIndex((r) => buildKey_(r) === targetKey);
    if (idx >= 0) rowNumber = rows[idx]._row;
  }

  if (rowNumber) {
    writeRow_(sheet, rowNumber, rec);
    return ContentService.createTextOutput(JSON.stringify({ ok: true, updated: true, row: rowNumber, data: rec }))
      .setMimeType(ContentService.MimeType.JSON);
  }

  const nextRow = lastRow + 1;
  writeRow_(sheet, nextRow, rec);
  return ContentService.createTextOutput(JSON.stringify({ ok: true, created: true, row: nextRow, data: rec }))
    .setMimeType(ContentService.MimeType.JSON);
}

function handleDelete_(payload) {
  const sheet = getSheet_();
  const rows = readRows_();
  const targetKey = payload.key ? String(payload.key).toUpperCase() : buildKey_({
    Company: payload.company,
    Model: payload.model,
    Variant: payload.variant,
  });
  const idx = rows.findIndex((r) => buildKey_(r) === targetKey);
  if (idx < 0) throw new Error('Record not found');
  const rowNumber = rows[idx]._row;
  sheet.deleteRow(rowNumber);
  return ContentService.createTextOutput(JSON.stringify({ ok: true, deleted: true, row: rowNumber }))
    .setMimeType(ContentService.MimeType.JSON);
}

function parseBody_(e) {
  if (!e) return {};
  if (e.postData && e.postData.contents) {
    try { return JSON.parse(e.postData.contents); } catch (_) { /* fall through */ }
  }
  if (e.parameter) {
    const obj = {};
    Object.keys(e.parameter).forEach((k) => { obj[k] = e.parameter[k]; });
    return obj;
  }
  return {};
}
