/**
 * Vehicle Catalog Web App (Google Apps Script)
 * Supports list / upsert / delete for Company, Model, Variant, Color, OnRoadPrice, plus audit (UpdatedAt/UpdatedBy).
 *
 * Deploy:
 *  - File > Project properties > copy Script ID for reference.
 *  - Deploy > New deployment > Select type "Web app".
 *  - Execute as: Me (the owner)
 *  - Who has access: Anyone with the link
 *  - After deploy, copy the Web App URL and set it in your client env as VITE_VEHICLE_CATALOG_GAS_URL.
 *
 * Expected sheet layout (first row headers):
 *  Company | Model | Variant | Color | OnRoadPrice | UpdatedAt | UpdatedBy
 */

// Target sheet: https://docs.google.com/spreadsheets/d/1XSwT6GQiXUsH_zH8VEymsrCfHb1QW_FbdKwMSqnE4_U/edit?gid=0#gid=0
const SPREADSHEET_ID = '1XSwT6GQiXUsH_zH8VEymsrCfHb1QW_FbdKwMSqnE4_U'; // Sheet ID
const SHEET_NAME = 'Catalog';

function getSheet_() {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheet = ss.getSheetByName(SHEET_NAME) || ss.insertSheet(SHEET_NAME);
  const headers = ['Company', 'Model', 'Variant', 'Color', 'OnRoadPrice', 'UpdatedAt', 'UpdatedBy'];
  const width = Math.max(sheet.getLastColumn(), headers.length);
  let firstRow = width ? sheet.getRange(1, 1, 1, width).getValues()[0] : [];
  if (!firstRow.length) {
    sheet.getRange(1, 1, 1, headers.length).setValues([headers]);
    return sheet;
  }
  const norm = (s) => String(s || '').trim().toLowerCase();
  const keyCols = [];
  firstRow.forEach((h, idx) => { if (norm(h) === 'key') keyCols.push(idx + 1); });
  if (keyCols.length) {
    for (let i = keyCols.length - 1; i >= 0; i--) {
      sheet.deleteColumn(keyCols[i]);
    }
    const newWidth = Math.max(sheet.getLastColumn(), headers.length);
    firstRow = newWidth ? sheet.getRange(1, 1, 1, newWidth).getValues()[0] : [];
  }
  const hasHeader = (h) => firstRow.findIndex((v) => norm(v) === norm(h)) !== -1;
  let updated = false;
  headers.forEach((h) => {
    if (!hasHeader(h)) {
      firstRow.push(h);
      updated = true;
    }
  });
  if (updated) sheet.getRange(1, 1, 1, firstRow.length).setValues([firstRow]);
  return sheet;
}

function buildKey_(obj) {
  const toKey = (s) => String(s || '').trim().toUpperCase();
  return [toKey(obj.Company), toKey(obj.Model), toKey(obj.Variant)].join('|');
}

function readRows_() {
  const sheet = getSheet_();
  const values = sheet.getDataRange().getValues();
  if (values.length <= 1) return [];
  const headers = values[0];
  const rows = [];
  for (let i = 1; i < values.length; i++) {
    const row = values[i];
    const obj = {};
    headers.forEach((h, idx) => { obj[h] = row[idx]; });
    obj._row = i + 1; // 1-based row index in Sheet
    rows.push(obj);
  }
  return rows;
}

function writeRow_(sheet, rowIndex, obj) {
  const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  const row = headers.map((h) => obj[h] ?? '');
  sheet.getRange(rowIndex, 1, 1, headers.length).setValues([row]);
}

function doGet(e) {
  const action = (e && e.parameter && e.parameter.action) ? String(e.parameter.action).toLowerCase() : 'list';
  if (action === 'list') {
    const rows = readRows_();
    return ContentService.createTextOutput(JSON.stringify({ ok: true, rows, count: rows.length })).setMimeType(ContentService.MimeType.JSON);
  }
  return ContentService.createTextOutput(JSON.stringify({ ok: true, message: 'Vehicle Catalog API' })).setMimeType(ContentService.MimeType.JSON);
}

function doPost(e) {
  const payload = parseBody_(e);
  const action = String(payload.action || 'upsert').toLowerCase();
  try {
    if (action === 'delete') {
      return handleDelete_(payload);
    }
    return handleUpsert_(payload);
  } catch (err) {
    return ContentService.createTextOutput(JSON.stringify({ ok: false, message: err.message || String(err) }))
      .setMimeType(ContentService.MimeType.JSON);
  }
}

function handleUpsert_(payload) {
  const sheet = getSheet_();
  const required = ['company', 'model', 'variant'];
  required.forEach((k) => {
    if (!payload[k]) throw new Error('Missing ' + k);
  });
  const colorRaw = payload.color || payload.colors || payload.Color || payload.Colours || '';
  const rec = {
    Company: String(payload.company).trim(),
    Model: String(payload.model).trim(),
    Variant: String(payload.variant).trim(),
    Color: String(colorRaw || '').trim(),
    OnRoadPrice: Number(payload.onRoadPrice || 0) || 0,
    UpdatedBy: payload.updatedBy ? String(payload.updatedBy).trim() : '',
  };
  rec.UpdatedAt = new Date();

  const rows = readRows_();
  const lastRow = sheet.getLastRow();
  const previousKey = buildKey_({
    Company: payload.previousCompany || payload.originalCompany,
    Model: payload.previousModel || payload.originalModel,
    Variant: payload.previousVariant || payload.originalVariant,
  });
  const targetKey = previousKey !== '||' ? previousKey : buildKey_(rec);
  const rowIdRaw = payload.id || payload.rowId || payload.row || payload._row;
  const rowId = rowIdRaw ? Number(rowIdRaw) : NaN;
  let rowNumber = null;

  if (!isNaN(rowId) && rowId >= 2 && rowId <= lastRow) {
    rowNumber = Math.floor(rowId);
  }

  if (!rowNumber) {
    const idx = rows.findIndex((r) => buildKey_(r) === targetKey);
    if (idx >= 0) rowNumber = rows[idx]._row;
  }

  const duplicate = rows.find((r) => r._row !== rowNumber && buildKey_(r) === buildKey_(rec));
  if (duplicate) {
    throw new Error('Duplicate vehicle for same Company + Model + Variant');
  }

  if (rowNumber) {
    writeRow_(sheet, rowNumber, rec);
    return ContentService.createTextOutput(JSON.stringify({ ok: true, updated: true, row: rowNumber, data: rec }))
      .setMimeType(ContentService.MimeType.JSON);
  }

  const nextRow = lastRow + 1;
  writeRow_(sheet, nextRow, rec);
  return ContentService.createTextOutput(JSON.stringify({ ok: true, created: true, row: nextRow, data: rec }))
    .setMimeType(ContentService.MimeType.JSON);
}

function handleDelete_(payload) {
  const sheet = getSheet_();
  const rows = readRows_();
  const targetKey = buildKey_({
    Company: payload.company,
    Model: payload.model,
    Variant: payload.variant,
  });
  const idx = rows.findIndex((r) => buildKey_(r) === targetKey);
  if (idx < 0) throw new Error('Record not found');
  const rowNumber = rows[idx]._row;
  sheet.deleteRow(rowNumber);
  return ContentService.createTextOutput(JSON.stringify({ ok: true, deleted: true, row: rowNumber }))
    .setMimeType(ContentService.MimeType.JSON);
}

function parseBody_(e) {
  if (!e) return {};
  if (e.postData && e.postData.contents) {
    try { return JSON.parse(e.postData.contents); } catch (_) { /* fall through */ }
  }
  if (e.parameter) {
    const obj = {};
    Object.keys(e.parameter).forEach((k) => { obj[k] = e.parameter[k]; });
    return obj;
  }
  return {};
}
